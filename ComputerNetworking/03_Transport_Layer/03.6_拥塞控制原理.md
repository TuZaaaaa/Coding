# 拥塞控制原理

## 场景1
- 2 个发送端，2 个接收端
- 一个路由器，具备无限大的缓冲
- 输出链路带宽
- 没有重传
- 每个连接的最大吞吐量 R/2
- 但进入的速率 $\lambda_{in}$ 接近链路带宽 R 时，延迟增大

## 场景2
- 一个路由器，有限的缓冲
- 分组丢失时，发送端重传
  - 应用层输入 = 应用层输出 $\lambda_{in} = \lambda_{out}$
  - 传输层的输入包括重传：$\lambda_{in}' >= \lambda_{in}$
  - $\lambda_{in}$: 原始数据
  - $\lambda_{in}'$: 原始数据 + 重传数据
- 理想化：发送端有完美的信息，发送端知道什么时候路由器的缓冲可用
  - 只在缓冲可用时发送
  - 不会丢失：$\lambda_{in}' = \lambda_{in}$
- 理想化2：掌握丢失信息
  - 分组可以丢失，由于路由器缓冲器满而丢弃
  - 分组丢失后，发送方重传分组
- 现实情况：重复
  - 分组可以丢失，由于路由器缓冲器满而丢弃
  - 发送端最终超时，发送 2 个拷贝，2 个分组都传送到
-  拥塞的代价
    - 为了达到一个有效输出，网络需要做很多工作（重传）
    - 没有必要的重传，链路中包括了多个分组的拷贝
        - 未丢失，但经历拥塞且超时的分组
        - 降低了的 gootput

## 场景3
- 4 个发送端
- 多重路径
- 超时/重传
- 拥塞的代价
  - 分组丢失后，任何”关于这个分组的上游传输能力”都浪费了（传输到第 n 个路由器后被丢失）

## 拥塞控制方法
- 端到端
  - 没有来自网络的显式反馈
  - 端系统根据延迟和丢失事件推断是否存在拥塞
    - 分组超时/冗余ACK
  - TCP 采用的方法
- 网络辅助
  - 路由器提供给端系统以反馈信息
    - 单个 bit 置位，显示有拥塞（SNA, DECbit, TCP/IP ECN, ATM）
    - 显式提供发送端可采用的速率

### ATM ABR 拥塞控制
- ABR: available bit rate
  - 弹性服务
  - 发送端路径轻载，使用可用带宽
  - 发送端路径拥塞，发送方限制其发送的速度到一个最小保障速率上
- RM（资源管理）信元：
  - 由发送端发送，在数据信元中间隔插入
  - RM 信元中的比特被交换机设置（网络辅助）
    - NI bit: no increase in rate(轻微拥塞)速率不要增加了
    - CI bit: congestion indication 拥塞指示
  - 发送端发送的 RM 信元被接收端返回，接收端不做任何改变
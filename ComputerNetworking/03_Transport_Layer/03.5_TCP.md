# TCP

## 特点
- 点对点
- 可靠、按顺序的字节流
  - 没有报文边界
- 流水线
  - 通过 拥塞控制 和 流量控制 设置大小
- 发送和接收缓存
- 全双工
- 面向连接
  - 数据交换前，通过握手（交换控制报文）初始化发送方和接收方的状态变量
  - 流量控制

## 报文段结构
- 32bit
- 源端口、目标端口
- 序号、确认号（确认 n-1 以及以前字节）（对字节计数）
- 首部长度、保留未用、URG(紧急数据，通常不用)、ACK、PSH(马上推出数据，通常不用)、（RST, SYN, FIN 建立/拆除连接）、接收窗口（愿意接收的字节数量）
- 校验和、紧急数据指针
- 可选项
- 应用层数据（长度可变）

## RTT
- RTT 估计
  - SampleRTT: 测试**发送**到**收到确认**的时间
    - 如果重传，忽略本次测量
    - 因为 RTT 非定值，所以对最近几次测量值求平均
  - $EstimatedRTT = (1-\alpha) * EstimatedRTT + \alpha * SampleRTT$
    - 指数加权移动平均
    - 过去样本的影响呈指数衰减
    - 推荐值：$\alpha = 0.125$
- 超时时长设置
  - 时长 > RTT
  - 过短：不必要的重传
  - 过长：消极、对丢失反应过慢
  - EstimatedRTT + 安全边界时间
    - EstimatedRTT 变化大（方差大）-> 较大的安全边界时间
  - SampleRTT 会偏离 EstimatedRTT 多远
    - $DevRTT = (1-\beta)*DevRTT+\beta*|SampleRTT-EstimatedRTT|$
    - 推荐值：$\beta = 0.25$
  - TimeoutInterval = EstimatedRTT + 4*DevRTT(safety margin)

## 可靠数据传输
### TCP 发送方事件
- 从应用层接收数据
  - 用 nextseq 创建报文段
  - 序号 nextseq 为报文段首字节的字节流编号
  - 如果还没有运行，启动定时器
    - 定时器与最早未确认的报文段关联
    - 过期间隔：TimeoutInterval
- 超时
  - 重传后沿最老的报文段
  - 重启定时器
- 收到确认
  - 如果是对尚未确认的报文段确认
    - 更新已被确认的报文序号
    - 如果还有未被确认的报文段，重启定时器

### 快速重传
- 超时周期往往太长
- 通过重复的 ACK 来检测报文段丢失
- 发送方收到同一数据的 3 个冗余 ACK，重传最小序号的段

### 流量控制
- Piggybacking
- 接收方在其向发送方的 TCP 段头部的 rwnd 字段“通告”其空闲 buffer 大小
  - RcvBuffer 大小通过 socket 选项设置（典型默认大小为 4096 字节）
  - 操作系统一般会自动调整 RcvBuffer
- 发送方限制未确认的字节的个数 <= 接收方发售过来的 rwnd 值，保证接收方不会被淹没

## 连接管理
### 连接建立
- 握手建立连接
  - 同意建立连接（相互知道对方同意）
  - 同意连接参数
- 为什么 2 次握手不可行
  - 变化的延迟（连接请求没有丢失，但是超时）
  - 丢失造成的重传
    - Q1: 导致服务器维持虚假的半连接
    - Q2: 老数据被当作新数据接收
  - 报文乱序
  - 相互看不到对方
- 3 次握手
  - 变化的初始序号 + 双方确认对方的序号

### 连接维护
- 数据通信

### 连接拆除
- 四次挥手、对称释放
- 客户端，服务器分别关闭它自己这一侧的连接
  - 发送 FIN bit=1 的 TCP 段
- 一旦接收到 FIN，用 ACK 回应
  - ACK 和它自己发出的 FIN 段一同发出
- 处理同时的 FIN 交换
- 步骤
  - 第一次挥手：客户端发送 FIN（表示自己不再发送数据）
  - 第二次挥手：服务端返回 ACK（确认客户端的 FIN）
  - 第三次挥手：服务端发送 FIN（表示自己不再发送数据）
  - 第四次挥手：客户端返回 ACK（确认服务端的 FIN）
- 为什么不能合并第二次和第三次挥手？
  - 服务端收到客户端的 FIN 后，可能还有未发送完的数据需要处理，此时只能先发送 ACK，而不能立即发送自己的 FIN

## 拥塞控制
- 拥塞：太多的数据需要网络传输，超过了网络处理能力
- 拥塞表现
  - 分组丢失（路由器缓冲区溢出）
  - 分组经历较长延迟（在路由器的队列中排队）
  - 网络中前 10 位的问题

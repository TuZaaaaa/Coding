# 图

## 图的定义
> $G = (V, E)$  $Graph = (Vertex, Edge)$
> - V：顶点（数据元素）的**有穷非空**集合
> - E：边的**有穷**集合

## 基本术语

- **无向图**：每条边都是无方向的
- **有向图**：每条边都是有方向的
- **完全图**：任意两个点都有一条边相连
    - **无向完全图**：n 个顶点，n(n-1)/2 条边
    - **有向完全图**：n 个顶点，n(n-1) 条边
- **稀疏图**：有很少边或弧的图（$e < nlog_n$）
- **稠密图**：有较多边或弧的图
- **网**：边/弧带权的图
- **邻接**：有边/弧相连的两个顶点之间的关系
    - 存在 $(v_i, v_j)$，则称 $v_i$ 和 $v_j$ 互为**邻接点**
    - 存在 $<v_i, v_j>$，则称 $v_i$ **邻接到** $v_j$，$v_j$ **邻接于** $v_i$
- **关联（依附）**：边/弧与顶点之间的关系
    - 存在 $(v_i, v_j)/<v_i, v_j>$，则称该边/弧关联于 $v_i$ 和 $v_j$
- **顶点的度**：与该顶点相关联的边的数目，记为 TD(v)
    - > 在有向图中，顶点的度等于该顶点的入度和出度之和
    - 顶点 v 的**入度**是以 v 为终点的有向边的条数，记作 ID(v)
    - 顶点 v 的**出度**是以 v 为始点的有向边的条数，记作 OD(v)
- **有向树**
    - 当有向图中仅有 1 个顶点的入度为 0，其余顶点的入度均为 1，此时是何形状？
- **路径**
    - 接续的边构成的顶点序列
- **路径长度**
    - 路径上边或弧的数目/权值之和
- **回路（环）** 
    - 第一个顶点和最后一个顶点相同的路径
- **简单路径**
    - 除路径起点和终点可以相同外，其余顶点均不相同的路径
- **简单回路（环）**
    - 除路径起点和终点相同外，其余顶点均不相同的路径
- **连通图（强连通图）**
    - 在无（有）向图 $G={V,{E}}$ 中，若对任何两个顶点 v, u
        - 都存在从 v 到 u 的路径，则称 G 是**连通图**（强连通图）
- **权**
    - 图中边或弧所具有的相关数称为**权**，表明从一个顶点到另一个顶点的距离或耗费
        - 带权的图称为**网**
- **子图**
    - 设有两个图 $G=(V,{E})、G1=(V1,{E1})$，若 $V1 \subseteq V, E1 \subseteq E$，则称 G1 是 G 的子图

- **连通分量（强连通分量）**
    - 无（有）向图 G 的**极大连通子图**称为 G 的**连通分量（强连通分量）**
    - > 极大连通子图意思是：该子图是 G 连通子图，将 G 的任何不在该子图中的顶点加入，子图不再连通（强连通）
- **极小连通子图**
    - 该子图是 G 的连通子图，在该子图中删除任何一条边，子图不再连通
- **生成树**
    - 包含无向图 G 所有顶点的极小连通子图
- **生成森林**
    - 对于非连通图，由各个连通分量的生成树的集合

## 图的类型定义

ADT Graph {
数据对象V：具有相同特性的数据元素的集合，称为顶点集
数据关系R：$R={VR}$
$VR=\{<v,w>|<v,w>|v,w \in V ^ p(v,w),\}$
$<v,w>$ 表示从 v 到 w 的弧，$P(v,w)$ 定义了弧 $<v,w>$ 的信息
基本操作：
- Create_Graph()：图的创建
    - 初始条件：无
    - 操作结果：生成一个没有顶点的空图 G
- GetVex(G,v)：求图中的顶点 v 的值
    - 初始条件：图 G 存在，v 是图中的一个顶点
    - 操作结果：生成一个没有顶点的空图 G
- CreateGraph(&G,V,VR)
    - 初始条件：V 是图的顶点集，VR 是图中弧的集合
    - 操作结果：按 V 和 VR 的定义**构造图 G**
- DFSTraverse(G)
    - 初始条件：图 G 存在
    - 操作结果：对图进行**深度优先遍历**
- BFSTraverse(G)
    - 初始条件：图 G 存在
    - 操作结果：对图进行**广度优先遍历**
}

## 图的存储结构
> 图没有顺序存储结构，但可以借助二维数组来表示元素间的关系
> 链式存储结构：多重链表
> - 邻接表
> - 邻接多重表
> - 十字链表
- 邻接矩阵（**数组**）表示法
- 邻接表（**链式**）表示法

###  邻接矩阵表示法
> 建立一个**顶点表**（记录各个顶点信息）和一个**邻接矩阵**（表示各个顶点之间关系）

- 设图 $A=(V,E)$ 有 n 个顶点，则

顶点表 Vexs[n]

| i | 0 | 1 | 2 | ... | n-1 |
| --- | --- | --- | --- | --- | --- |
| Vex[i] | $V_1$ | $V_2$ | $V_3$ | ... | $V_n$ |

- 图的邻接矩阵是一个二维数组 $A.arcs[n][n]$，定义为：
- $A.arcs[i][j]$
    - 1 如果 $<i,j> \in E$ 或者 $(i,j) \in E$
    - 0 否则

#### 无向图的邻接矩阵
- 无向图的邻接矩阵是**对称**的（对称矩阵）
- 顶点 i 的**度** = 第 i 行（列）中 **1** 的个数
> 完全图的邻接矩阵中，对角元素为 0，其余为 1

#### 有向图的邻接矩阵
- 第 **i** 行含义：以结点 $v_i$ 为尾的弧（即出度边）
- 第 **i** 列含义：以结点 $v_i$ 为头的弧（即入度边）
- 有向图的邻接矩阵**可能是不对称**的
- 顶点的**出度 = 第 i 行元素之和**
- 顶点的**出度 = 第 i 列元素之和**
- **顶点的出度 = 第 i 行元素之和 + 第 i 列元素之和**

#### 网（即有权图）的邻接矩阵
定义为：
- $A.arcs[i][j] = $
    - $W_{ij}$ $<vi,vj>$ 或 $(vi,vj) \in VR$
    - $\infty$ 无边（弧）

#### 邻接矩阵的建立

- 邻接矩阵的存储表示：用**两个数组**分别存储**顶点表**和**邻接矩阵**
```c
#define MaxInt 32767 // 表示极大值，即 无穷
#define MVNum 100 // 最大顶点数
typedef cahr VerTexType; // 设顶点的数据类型为字符型
typedef int ArcType; // 假设边的权值类型为整型

typedef struct {
    VerTexType vexs[MVNum]; // 顶点表
    ArcType arcs[MVNum][MVNum]; // 邻接矩阵
    int vexnum, arcnum; // 图的当前点数和边数
} AMGraph; // Adjacency Matrix Graph
```

##### 采用邻接矩阵表示法创建无向网

**算法思想：**
1. 输入**总顶点数和总边数**
2. 依次输入**点的信息存入顶点表**中
3. **初始化邻接矩阵**，使每个权值初始化为极大值
4. **构造邻接矩阵**

> - 无向图：
>   - 初始化邻接矩阵时，w 均为 0
>   - 构造邻接矩阵时，w 为 1
> - 有向网：
>   - 邻接矩阵是非对称矩阵
>       - 仅为 $G.arcs[i][j]$ 赋值
>       - 无需为 $G.arcs[j][i]$ 赋值


**算法实现：**
```c
// 采用邻接矩阵表示法，创建无向网 G
Status CreateUDN(AMGraph &G) {
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数，总边数
    for(i = 0;i < G.vexnum;++i)
        cin >> G.vexs[i]; // 依次输入点的信息
    for(i = 0;i < G.vexnum;++i)
        for(j = 0;j < G.vexnum;++j)
            G.arcs[i][j] = MaxInt; // 边的权值均置为极大值
    // 构造邻接矩阵
    for(k = 0;k < G.vexnum;++k) {
        cin >> v1 >> v2 >> w; // 输入一条边所依附的顶点及边的权值
        i = LocateVex(G, v1);
        j = LocateVex(G, v2); // 确定 v1 和 v2 在 G 中的位置
        G.arcs[i][j] = w; // 边 <v1,v2> 的权值置为 w
        G.arcs[j][i] = G.arcs[i][j]; // 置 <v1,v2> 的对称边 <v2,v1> 的权值为 w
    }
    return OK;
} // CreateUDN


// 补充算法：在图中查找顶点
// 图 G 中查找顶点 u，存在则返回顶点表中的下标，否则返回 -1
int LocateVex(AMGraph G, VertexType u) {
    int i;
    for(i = 0;i < G.vexnum;++i) {
        if(u == G.vexs[i]) {
            return i;
        }
    }
    return -1;
}
```

### 邻接表表示法（链式）

- 顶点
    - 按编号顺序将顶点数据存储在**一维数组**中
- 关联同一顶点的边（以顶点为尾的弧）
    - 用线性**链表**存储
- 头结点
    - data
    - firstarc
- 表结点
    - adjvex **邻接点域**，存放与 $V_i$ 邻接的顶点在表头数组中的位置
    - nextarc **链域**，指示下一条边或弧
    - info 可选，用于存放权值或其他信息

#### 无向图的邻接表

特点：
- 邻接表不唯一
- 若**无向图**中有 **n** 个顶点、**e** 条边，则其邻接表需 **n** 个头结点和 **2e** 个表结点，适宜存储稀疏图，空间复杂度：$O(n+2e)$
- **无向图**中顶点 $v_i$ 的度为第 i 个单链表中的结点数

#### 有向图的邻接表

特点：
- 顶点 $v_i$ 的**出度**为第 i 个单链表中的结点个数
- 顶点 $v_i$ 的**入度**为整个单链表中邻接点域值是 i-1 的结点个数

> 找出度易，找入度难

##### 逆邻接表

特点：
- 顶点 $v_i$ 的**入度**为第 i 个单链表中的结点个数
- 顶点 $v_i$ 的**出度**为整个单链表中邻接点域值是 i-1 的结点个数

> 找入度易，找出度难

#### 总结
> 当邻接表的存储结构形成后，图便唯一确定

### 建立邻接表算法

顶点的结点结构：
    - data
    - firstarc

```c
typedef struct VNode {
    VerTexType data; // 顶点信息
    ArcNode *firstarc; // 指向第一条依附该顶点的边的指针
}VNode, Adjust[MVNum]; // AdjList 表示邻接表类型
```

弧（边）的结点结构：
    - adjvex
    - nextarc
    - info

```c
#define MVNum 100 // 最大顶点数
typedef struct ArcNode { // 边结点
    int adjvex; // 该边所指向的顶点的位置
    struct ArcNode *nextarc; // 指向下一条边的指针
    OtherInfo info; // 和边相关的信息
}ArcNode;
```

图的结构定义：

```c
typedef struct {
    AdjList vertices; // vertices -- vertex 的复数
    int vexnum, arcnum; // 图的当前顶点数和弧数
}ALGraph;
```

#### 采用邻接表表示法创建无向网

算法思想：
1. 输入总顶点数和总边数
2. 建立顶点表
   1. 依次输入点的信息存入顶点表中
   2. 使每个表头结点的指针域初始化为 NULL
3. 创建邻接表
   1. 依次输入每条边依附的两个顶点
   2. 确定两个顶点的序号 i 和 j，建立边结点
   3. 将此边结点分别插入到 $v_i$ 和 $v_j$ 对应的两个边链表的头部

算法实现：
```c
Status CreateUDG(ALGraph &G) { // 采用邻接表表示法，创建无向图 G
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数，总边数
    for(i = 0;i < G.vexnum;++i) { // 输入各点，构造表头结点表
        cin >> G.vertices[i].data; // 输入顶点值
        G.vertices[i].firstarc = NULL; // 初始化表头结点的指针域
    }//for
    for(k = 0;k < G.arcnum;++K) { // 输入各边，构造邻接表
        cin >> v1 >> v2;
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        p1 = new ArcNode; // 生成一个新的边结点 *p1
        p1 -> adjvex = j; // 邻接点序号为 j
        p1 -> nextarc = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p1; // 将新结点 *p1 插入顶点 vi 的边表头部
        p2 = new ArcNode; // 生成另一个对称的新的边结点 *p2
        p2 -> adjvex = i; // 邻接点序号为 i
        p2 -> nextarc = G.vertices[j].firstarc;
        G.vertices[j].firstarc = p2; // 将新结点 *p2 插入顶点 vi 的边表头部
    }//for
    return OK;
}//CreateUDG
```

#### 邻接表表示法特点

**特点：**
1. 方便查找任一顶点的所有“邻接点”
2. 节约稀疏图的空间
    - 需要 N 个头指针 + 2E 个节点（每个结点至少 2 个域）
3. 方便计算任一顶点的“度”？
    - 无向图：是的
    - 有向图：只能计算“出度”，需要构造“逆邻接表”（存指向自己的边）来方便计算“入度”
4. 不方便检查任一对顶点间是否存在边

#### 邻接矩阵与邻接表表示法

##### 联系
> 邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数

##### 区别
1. 对于任一确定的无向图，邻接矩阵是**唯一**的（行列号与顶点编号一致），但邻接表**不唯一**（链接次序和顶点编号无关）
2. 邻接矩阵的空间复杂度为 $O(n^2)$，而邻接表的空间复杂度为 $O(n+e)$

##### 用途
> 邻接矩阵多用于**稠密图**，而邻接表多用于**稀疏图**


### 十字链表（用于有向图）
> 用于解决邻接表**求结点的度困难**的问题（出入度）

- 顶点结点
  - data
  - firstin
  - firstout
- 弧结点
  - tailvex
  - headvex
  - hlink
  - tlink

### 邻接多重表
> 用于解决邻接表**每条边都要存储两遍**的问题

- 顶点结点
  - data 存储与顶点有关的信息
  - firstedge 指向第一条依附于该结点的边
- 边结点
  - mark 标志域，标记此边是否被搜索过（可选）
  - ivex 该边依附的两个顶点在表头数组中的位置
  - ilink 指向依附于 ivex 的下一条边
  - jvex 该边依附的两个顶点在表头数组中的位置
  - ilink 指向依附于 jvex 的下一条边
  - info 记录权值等信息（可选）

## 图的遍历

**遍历定义：**
> 从给定的连通图中某一顶点出发，沿着一些边访问图中所有顶点，且每个顶点仅被访问一次，就称为**图的遍历**，它是图的**基本运算**
> 遍历实质：寻找每个顶点的邻接点的过程

**图的特点：**
> 图中可能存在**回路**，且图的任一顶点 都可能与其他顶点相通，在访问完某个顶点之后可能会沿着某些边**又回到了曾经访问的顶点**

**如何避免重复访问？**
> 思路：设置辅助数组 visited[n]，用来标记每个被访问的顶点
- 初始状态 visisted[i] 为 0
- **顶点 i 被访问，修改 visited[i] 为 1**，防止被多次访问

### 深度优先遍历
> Depth First Search DFS

**方法：**
1. 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 $w_1$
2. 再从 $w_1$ 出发，访问与 $w_1$ 邻接但还未被访问过的顶点 $w_2$
3. 然后再从 $w_2$ 出发，进行类似的访问
4. 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止
5. 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问过的邻接顶点
    - 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问
    - 如果没有，则退回一步进行搜索，重复上述过程，指导连通图中所有顶点都被访问过为止

#### 邻接矩阵的实现
```c
void DFS(AMGraph G, int v) { // 图 G 为邻接矩阵类型
    cout << v; visited[v] = true; // 访问第 v 个顶点
    for(w = 0;w < G.vexnum;w++) { // 依次检查邻接矩阵 v 所在的行
        if(G.arcs[v][w] != 0 && (!visited[w])) {
            DFS(G, w); // w 是 v 的邻接点，如果 w 未访问，则递归调用 DFS
        }
    }
}
```

#### 算法效率分析
- 邻接矩阵
  - > 遍历图中每个顶点都要**从头扫描**该顶点所在行，时间复杂度 $O(n^2)$
- 邻接表
  - > 虽然有 $2e$ 个表结点，但只需扫描 **e** 个结点即可完成遍历，加上访问 **n** 个头结点的时间，时间复杂度为 $O(n+e)$
> 结论
> - **稠密图**适于在邻接矩阵上进行深度遍历
> - **稀疏图**适于在邻接表上进行深度遍历


### 广度优先遍历
> Brandth First Search BFS

**方法**
- 从图的某一结点出发，依次访问该结点的所有邻接点 $Vi_1, Vi_2, ..., Vi_n$ 再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的结点
- 重复此过程，直至所有顶点均被访问为止

**非递归遍历连通图 G 算法实现**
```c
void BFS(Graph G, int v) { // 按广度优先非递归遍历连通图 G
    cout << v; visited[v] = true; // 访问第 v 个顶点
    InitQueue(Q); // 辅助队列 Q 初始化，置空
    EnQueue(Q, v); // v 进队
    while(!QueueEmpty(Q)) { // 队列非空
        DeQueue(Q, u); // 队头元素出队并置为 u
        for(w = FirstAdjVex(G, u); w >= 0;w = NextAdjVex(G, u, w)) {
            if (!visited[w]) {
                cout << w; visited[w] = true; EnQueue(Q, w); // 从 w 进队
            } // if
        } // for
    } // while
} // BFS
```

#### BFS 算法效率分析
- 如果使用邻接矩阵，则 BFS 对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（n 个元素），总的时间复杂度为 $O(n_2)$
- 用邻接表表示图，虽然有 2e 个表结点，但只需要扫描 e 个结点即可完成遍历，加上访问 n 个头结点的时间，时间复杂度为 $O(n+e)$

### DFS 与 BFS 算法效率比较
- 空间复杂度相同，都是 $O(n)$（借用了堆栈或队列）
- **时间复杂度只与存储结构有关，与搜索路径无关**


## 图的应用

### 概念回顾-生成树
- 所有顶点均由边连接在一起，但**不存在回路**
- 一个图可以有许多颗不同的生成树
- 所有生成树具有以下共同特点
  - 生成树的顶点个数与图的**顶点个数相同**
  - 生成树是图的**极小连通子图**，去掉一条边则非连通
  - 一个有 n 个顶点的连通图的生成树有 **n-1** 条边
  - **在生成树中再加一条边必然形成回路**
  - 生成树中任一两个顶点间的**路径是唯一**的

> 设图 $G=(V, E)$ 是个连通图，当从图任一顶点出发遍历图 G 时，将边集 $E(G)$ 分成两个集合 $T(G)$ 和 $B(G)$
> - $T(G)$ 是遍历图时所经过的边的集合
> - $B(G)$ 时遍历图时未经过的边的集合
> 显然，$G1(V, T)$ 是图 G 的极小连通子图，即子图 G1 是连通图 G 的生成树

> 最小生成树：给定一个无向网络，在该网的所有生成树中，使得**各边权值之和最小**的那棵生成树称为该网的**最小生成树**，也叫**最小代价生成树**

### 最小生成树的典型用途
- 欲在 n 个城市间建立通信网，则 n 个城市应铺 n-1 条线路
- 因每条线路都会有对应的经济成本，而 n 个城市最多有 n(n-1) / 2 条线路，那么，**如何选择 n-1 条线路，使总费用最少？**

- 数学模型
    - 顶点：表示城市，有 n 个
    - 边：表示线路，有 n-1 条
    - 边的权值：表示线路的经济代价
    - 连通网：表示 n 个城市间通信网

### 构造最小生成树

#### MST 性质
> MST(Minimum Spanning Tree)
> 设 $N = (V, E)$ 是一个连通网，U 是顶点集 V 的一个非空子集
> 若边 $(u, v)$ 是一条具有最小权值的边，其中 $u \in U, v \in V-U$，则必存在一棵包含边 $(u, v)$ 的最小生成树

- 在生成树的构造过程中，图中 n 个顶点分属两个结合
    - 已落在生成树上的顶点集：U
    - 尚未落在生成树上的顶点集：V-U
- 接下来则应在所有连通 U 中顶点和 V-U 中顶点的边中选取**权值最小的边**

#### Prim 算法

**算法思想：**
- 设 $N = (V,E)$ 是连通网，TE 是 N 上最小生成树中**边的集合**
- 初始令 $U=\{u_0\},(u_0 \in V), TE = \{\}$
- 在所有 $u \in U, v \in V-U$ 的边 $(u,v) \in E)$ 中，找一条代价最小的边 $(u_0,v_0)$
- 将 $(u_0,v_0)$ 并入集合 TE，同时 $v_0$ 并入 U
- 重复上述操作直至 $U=V$ 为止，则 $T=(V,TE))$ 为 N 的最小生成树

#### Kruskal 算法

**算法思想：**
- 设连通网 $N=(V,E)$，令最小生成树初始状态为**只有 n 个顶点而无边的非连通图** $T=(V,{})$，每个顶点自成一个连通分量
- 在 E 中选取代价最小的边，若该边依附的顶点落在 T 中不同的连通分量上（即：不能形成环），则将此边加入到 T 中
    - 否则，舍去此边，选取下一条代价最小的边
- 依次类推，直至 T 中所有顶点都在同一连通分量上为止
> 最小生成树可能不唯一


#### 两种算法比较
| 算法名 | Prim | Kruskal |
| --- | --- | --- |
| 算法思想 | 选择点 | 选择边 |
| 时间复杂度 | $O(n^2)（n 为顶点数）$ | $O(eloge)（e 为边数）$
| 适应范围 | 稠密图 | 稀疏图 |

### 求最短路径

**典型用途**
> 交通网络的问题 从甲地到乙地之间是否有公路连通？在有多条通路的情况下，哪一条路最短？
交通网络用**有向网**来表示
- 顶点：表示地点
- 弧：表示两个地点有路连通
- 弧上的权值：表示两地之间的距离、交通费或途中所花费的时间等
**问题抽象**
> 在有向网中 A 点（源点）到达 B 点（终点）的多条路径中，寻找一条**各边权值之和最小**的路径，即**最短路径**
> 最短路径与最小生成树不同，路径上不一定包含 n 个顶点，也不一定包含 n-1 条边


#### Dijkstra 算法
> 单源最短路径问题

**算法思路**
1. 初始化：先找出从源点 $v_0$ 到各终点 $v_k$ 的直达路径 $(v_0,v_k)$
    - 即通过一条弧到达的路径
2. 选择：从这些路径中找出一条长度最短的路径 $(v_0,u)$
3. 更新：然后对其余各条路径进行适当调整
    - **若在图中存在弧 $(u,v_k)$，且 $(v_0,u)+(u,v_k)<(v_0,v_k)$**
        - 则以路径 $(v_0,u,v_k)$ 代替 $(v_0,v_k)$

**按路径长度递增次序产生最短路径**
1. 把 V 分成两组
   1. S：已求出最短路径的顶点的集合
   2. T=V-S：尚未确定最短路径的顶点集合
2. 将 T 中顶点按最短路径递增的次序加入到 S 中
    - **保证：**
        1. 从源点 $v_0$ 到 S 中各顶点的最短路径长度都不大于从 $v_0$ 到 T 中任何顶点的最短路径长度
        2. 每个顶点对应一个**距离值**
            - S 中顶点：从 $v_0$ 到此顶点的最短路径长度
            - T 中顶点：从 $v_0$ 到此顶点的只包括 S 中顶点作中间顶点的最短路径长度

**算法步骤**
初始时令 $S=\{v_0\} T=\{其余顶点\}$ 
- T 中顶点对应的距离值用辅助数组 D 存放
- **D[i]初值：**若 $<v_0,v_i>$ 存在，则为其权值，否则为 $\infty$
- 从 T 中选取一个其距离值最小的顶点 $v_j$，加入 S
- 对 T 中顶点的距离值进行修改：若加进 $v_j$ 作中间顶点，从 $v_0$ 到 $v_i$ 的距离值比不加 $v_j$ 的路径要短，则修改此距离值
- 重复上述步骤，直到 $S=V$ 为止

#### Floyd 算法
> 所有顶点间的最短路径问题（也可采用 Dijkstra 算法 n 次）

**算法思想**
- 逐个顶点**试探**
- 从 $v_i$ 到 $v_j$ 的所有可能**存在的**路径中
- 选出一条长度**最短的**路径

**算法步骤**
- 初始时设置一个 n 阶方阵，令其对角线元素为 0，若存在弧 $<v_i,v_j>$，则对应元素为权值，否则为 $\infty$
- 逐步试着在原直接路径中增加中间顶点
    - 若加入中间顶点后路径变短，则修改之
    - 否则，维持原值
- 所有顶点试探完毕，算法结束

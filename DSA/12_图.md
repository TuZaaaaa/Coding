# 图

## 图的定义
> $G = (V, E)$  $Graph = (Vertex, Edge)$
> - V：顶点（数据元素）的**有穷非空**集合
> - E：边的**有穷**集合

## 基本术语

- **无向图**：每条边都是无方向的
- **有向图**：每条边都是有方向的
- **完全图**：任意两个点都有一条边相连
    - **无向完全图**：n 个顶点，n(n-1)/2 条边
    - **有向完全图**：n 个顶点，n(n-1) 条边
- **稀疏图**：有很少边或弧的图（$e < nlog_n$）
- **稠密图**：有较多边或弧的图
- **网**：边/弧带权的图
- **邻接**：有边/弧相连的两个顶点之间的关系
    - 存在 $(v_i, v_j)$，则称 $v_i$ 和 $v_j$ 互为**邻接点**
    - 存在 $<v_i, v_j>$，则称 $v_i$ **邻接到** $v_j$，$v_j$ **邻接于** $v_i$
- **关联（依附）**：边/弧与顶点之间的关系
    - 存在 $(v_i, v_j)/<v_i, v_j>$，则称该边/弧关联于 $v_i$ 和 $v_j$
- **顶点的度**：与该顶点相关联的边的数目，记为 TD(v)
    - > 在有向图中，顶点的度等于该顶点的入度和出度之和
    - 顶点 v 的**入度**是以 v 为终点的有向边的条数，记作 ID(v)
    - 顶点 v 的**出度**是以 v 为始点的有向边的条数，记作 OD(v)
- **有向树**
    - 当有向图中仅有 1 个顶点的入度为 0，其余顶点的入度均为 1，此时是何形状？
- **路径**
    - 接续的边构成的顶点序列
- **路径长度**
    - 路径上边或弧的数目/权值之和
- **回路（环）** 
    - 第一个顶点和最后一个顶点相同的路径
- **简单路径**
    - 除路径起点和终点可以相同外，其余顶点均不相同的路径
- **简单回路（环）**
    - 除路径起点和终点相同外，其余顶点均不相同的路径
- **连通图（强连通图）**
    - 在无（有）向图 $G={V,{E}}$ 中，若对任何两个顶点 v, u
        - 都存在从 v 到 u 的路径，则称 G 是**连通图**（强连通图）
- **权**
    - 图中边或弧所具有的相关数称为**权**，表明从一个顶点到另一个顶点的距离或耗费
        - 带权的图称为**网**
- **子图**
    - 设有两个图 $G=(V,{E})、G1=(V1,{E1})$，若 $V1 \subseteq V, E1 \subseteq E$，则称 G1 是 G 的子图

- **连通分量（强连通分量）**
    - 无（有）向图 G 的**极大连通子图**称为 G 的**连通分量（强连通分量）**
    - > 极大连通子图意思是：该子图是 G 连通子图，将 G 的任何不在该子图中的顶点加入，子图不再连通（强连通）
- **极小连通子图**
    - 该子图是 G 的连通子图，在该子图中删除任何一条边，子图不再连通
- **生成树**
    - 包含无向图 G 所有顶点的极小连通子图
- **生成森林**
    - 对于非连通图，由各个连通分量的生成树的集合

## 图的类型定义

ADT Graph {
数据对象V：具有相同特性的数据元素的集合，称为顶点集
数据关系R：$R={VR}$
$VR=\{<v,w>|<v,w>|v,w \in V ^ p(v,w),\}$
$<v,w>$ 表示从 v 到 w 的弧，$P(v,w)$ 定义了弧 $<v,w>$ 的信息
基本操作：
- Create_Graph()：图的创建
    - 初始条件：无
    - 操作结果：生成一个没有顶点的空图 G
- GetVex(G,v)：求图中的顶点 v 的值
    - 初始条件：图 G 存在，v 是图中的一个顶点
    - 操作结果：生成一个没有顶点的空图 G
- CreateGraph(&G,V,VR)
    - 初始条件：V 是图的顶点集，VR 是图中弧的集合
    - 操作结果：按 V 和 VR 的定义**构造图 G**
- DFSTraverse(G)
    - 初始条件：图 G 存在
    - 操作结果：对图进行**深度优先遍历**
- BFSTraverse(G)
    - 初始条件：图 G 存在
    - 操作结果：对图进行**广度优先遍历**
}

## 图的存储结构
> 图没有顺序存储结构，但可以借助二维数组来表示元素间的关系
> 链式存储结构：多重链表
> - 邻接表
> - 邻接多重表
> - 十字链表
- 邻接矩阵（**数组**）表示法
- 邻接表（**链式**）表示法

###  邻接矩阵表示法
> 建立一个**顶点表**（记录各个顶点信息）和一个**邻接矩阵**（表示各个顶点之间关系）

- 设图 $A=(V,E)$ 有 n 个顶点，则

顶点表 Vexs[n]

| i | 0 | 1 | 2 | ... | n-1 |
| --- | --- | --- | --- | --- | --- |
| Vex[i] | $V_1$ | $V_2$ | $V_3$ | ... | $V_n$ |

- 图的邻接矩阵是一个二维数组 $A.arcs[n][n]$，定义为：
- $A.arcs[i][j]$
    - 1 如果 $<i,j> \in E$ 或者 $(i,j) \in E$
    - 0 否则

#### 无向图的邻接矩阵
- 无向图的邻接矩阵是**对称**的（对称矩阵）
- 顶点 i 的**度** = 第 i 行（列）中 **1** 的个数
> 完全图的邻接矩阵中，对角元素为 0，其余为 1

#### 有向图的邻接矩阵
- 第 **i** 行含义：以结点 $v_i$ 为尾的弧（即出度边）
- 第 **i** 列含义：以结点 $v_i$ 为头的弧（即入度边）
- 有向图的邻接矩阵**可能是不对称**的
- 顶点的**出度 = 第 i 行元素之和**
- 顶点的**出度 = 第 i 列元素之和**
- **顶点的出度 = 第 i 行元素之和 + 第 i 列元素之和**

#### 网（即有权图）的邻接矩阵
定义为：
- $A.arcs[i][j] = $
    - $W_{ij}$ $<vi,vj>$ 或 $(vi,vj) \in VR$
    - $\infty$ 无边（弧）

#### 邻接矩阵的建立

- 邻接矩阵的存储表示：用**两个数组**分别存储**顶点表**和**邻接矩阵**
```c
#define MaxInt 32767 // 表示极大值，即 无穷
#define MVNum 100 // 最大顶点数
typedef cahr VerTexType; // 设顶点的数据类型为字符型
typedef int ArcType; // 假设边的权值类型为整型

typedef struct {
    VerTexType vexs[MVNum]; // 顶点表
    ArcType arcs[MVNum][MVNum]; // 邻接矩阵
    int vexnum, arcnum; // 图的当前点数和边数
} AMGraph; // Adjacency Matrix Graph
```

##### 采用邻接矩阵表示法创建无向网

**算法思想：**
1. 输入**总顶点数和总边数**
2. 依次输入**点的信息存入顶点表**中
3. **初始化邻接矩阵**，使每个权值初始化为极大值
4. **构造邻接矩阵**

> - 无向图：
>   - 初始化邻接矩阵时，w 均为 0
>   - 构造邻接矩阵时，w 为 1
> - 有向网：
>   - 邻接矩阵是非对称矩阵
>       - 仅为 $G.arcs[i][j]$ 赋值
>       - 无需为 $G.arcs[j][i]$ 赋值


**算法实现：**
```c
// 采用邻接矩阵表示法，创建无向网 G
Status CreateUDN(AMGraph &G) {
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数，总边数
    for(i = 0;i < G.vexnum;++i)
        cin >> G.vexs[i]; // 依次输入点的信息
    for(i = 0;i < G.vexnum;++i)
        for(j = 0;j < G.vexnum;++j)
            G.arcs[i][j] = MaxInt; // 边的权值均置为极大值
    // 构造邻接矩阵
    for(k = 0;k < G.vexnum;++k) {
        cin >> v1 >> v2 >> w; // 输入一条边所依附的顶点及边的权值
        i = LocateVex(G, v1);
        j = LocateVex(G, v2); // 确定 v1 和 v2 在 G 中的位置
        G.arcs[i][j] = w; // 边 <v1,v2> 的权值置为 w
        G.arcs[j][i] = G.arcs[i][j]; // 置 <v1,v2> 的对称边 <v2,v1> 的权值为 w
    }
    return OK;
} // CreateUDN


// 补充算法：在图中查找顶点
// 图 G 中查找顶点 u，存在则返回顶点表中的下标，否则返回 -1
int LocateVex(AMGraph G, VertexType u) {
    int i;
    for(i = 0;i < G.vexnum;++i) {
        if(u == G.vexs[i]) {
            return i;
        }
    }
    return -1;
}
```

### 邻接表表示法（链式）

- 顶点
    - 按编号顺序将顶点数据存储在**一维数组**中
- 关联同一顶点的边（以顶点为尾的弧）
    - 用线性**链表**存储
- 头结点
    - data
    - firstarc
- 表结点
    - adjvex **邻接点域**，存放与 $V_i$ 邻接的顶点在表头数组中的位置
    - nextarc **链域**，指示下一条边或弧
    - info 可选，用于存放权值或其他信息

#### 无向图的邻接表

特点：
- 邻接表不唯一
- 若**无向图**中有 **n** 个顶点、**e** 条边，则其邻接表需 **n** 个头结点和 **2e** 个表结点，适宜存储稀疏图，空间复杂度：$O(n+2e)$
- **无向图**中顶点 $v_i$ 的度为第 i 个单链表中的结点数

#### 有向图的邻接表

特点：
- 顶点 $v_i$ 的**出度**为第 i 个单链表中的结点个数
- 顶点 $v_i$ 的**入度**为整个单链表中邻接点域值是 i-1 的结点个数

> 找出度易，找入度难

##### 逆邻接表

特点：
- 顶点 $v_i$ 的**入度**为第 i 个单链表中的结点个数
- 顶点 $v_i$ 的**出度**为整个单链表中邻接点域值是 i-1 的结点个数

> 找入度易，找出度难

#### 总结
> 当邻接表的存储结构形成后，图便唯一确定

### 建立邻接表算法

顶点的结点结构：
    - data
    - firstarc

```c
typedef struct VNode {
    VerTexType data; // 顶点信息
    ArcNode *firstarc; // 指向第一条依附该顶点的边的指针
}VNode, Adjust[MVNum]; // AdjList 表示邻接表类型
```

弧（边）的结点结构：
    - adjvex
    - nextarc
    - info

```c
#define MVNum 100 // 最大顶点数
typedef struct ArcNode { // 边结点
    int adjvex; // 该边所指向的顶点的位置
    struct ArcNode *nextarc; // 指向下一条边的指针
    OtherInfo info; // 和边相关的信息
}ArcNode;
```

图的结构定义：

```c
typedef struct {
    AdjList vertices; // vertices -- vertex 的复数
    int vexnum, arcnum; // 图的当前顶点数和弧数
}ALGraph;
```

#### 采用邻接表表示法创建无向网

算法思想：
1. 输入总顶点数和总边数
2. 建立顶点表
   1. 依次输入点的信息存入顶点表中
   2. 使每个表头结点的指针域初始化为 NULL
3. 创建邻接表
   1. 依次输入每条边依附的两个顶点
   2. 确定两个顶点的序号 i 和 j，建立边结点
   3. 将此边结点分别插入到 $v_i$ 和 $v_j$ 对应的两个边链表的头部

算法实现：
```c
Status CreateUDG(ALGraph &G) { // 采用邻接表表示法，创建无向图 G
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数，总边数
    for(i = 0;i < G.vexnum;++i) { // 输入各点，构造表头结点表
        cin >> G.vertices[i].data; // 输入顶点值
        G.vertices[i].firstarc = NULL; // 初始化表头结点的指针域
    }//for
    for(k = 0;k < G.arcnum;++K) { // 输入各边，构造邻接表
        cin >> v1 >> v2;
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        p1 = new ArcNode; // 生成一个新的边结点 *p1
        p1 -> adjvex = j; // 邻接点序号为 j
        p1 -> nextarc = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p1; // 将新结点 *p1 插入顶点 vi 的边表头部
        p2 = new ArcNode; // 生成另一个对称的新的边结点 *p2
        p2 -> adjvex = i; // 邻接点序号为 i
        p2 -> nextarc = G.vertices[j].firstarc;
        G.vertices[j].firstarc = p2; // 将新结点 *p2 插入顶点 vi 的边表头部
    }//for
    return OK;
}//CreateUDG
```

#### 邻接表表示法特点

**特点：**
1. 方便查找任一顶点的所有“邻接点”
2. 节约稀疏图的空间
    - 需要 N 个头指针 + 2E 个节点（每个结点至少 2 个域）
3. 方便计算任一顶点的“度”？
    - 无向图：是的
    - 有向图：只能计算“出度”，需要构造“逆邻接表”（存指向自己的边）来方便计算“入度”
4. 不方便检查任一对顶点间是否存在边

#### 邻接矩阵与邻接表表示法

##### 联系
> 邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数

##### 区别
1. 对于任一确定的无向图，邻接矩阵是**唯一**的（行列号与顶点编号一致），但邻接表**不唯一**（链接次序和顶点编号无关）
2. 邻接矩阵的空间复杂度为 $O(n^2)$，而邻接表的空间复杂度为 $O(n+e)$

##### 用途
> 邻接矩阵多用于**稠密图**，而邻接表多用于**稀疏图**


### 十字链表（用于有向图）
> 用于解决邻接表**求结点的度困难**的问题（出入度）

- 顶点结点
  - data
  - firstin
  - firstout
- 弧结点
  - tailvex
  - headvex
  - hlink
  - tlink

### 邻接多重表
> 用于解决邻接表**每条边都要存储两遍**的问题

- 顶点结点
  - data 存储与顶点有关的信息
  - firstedge 指向第一条依附于该结点的边
- 边结点
  - mark 标志域，标记此边是否被搜索过（可选）
  - ivex 该边依附的两个顶点在表头数组中的位置
  - ilink 指向依附于 ivex 的下一条边
  - jvex 该边依附的两个顶点在表头数组中的位置
  - ilink 指向依附于 jvex 的下一条边
  - info 记录权值等信息（可选）

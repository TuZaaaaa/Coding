# 链表
## 链式存储结构
> 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻
> 线性表的链式表示又称为**非顺序映像**或**链式映像**

### 线性表的链式表示和实现
> 用一组**物理位置任意的存储单元**来存放线性表的数据元素
> 这组存储单元既可以是**连续**的，也可以是**不连续**的，甚至是零散分布在内存中的任意位置上的

- 链表中元素的**逻辑次序和物理次序不一定相同**

### 基本术语
- 结点
  - 数据元素的存储映像，由数据域和指针域两部分组成
    - 数据域：存储元素数值数据
    - 指针域：存储直接后继结点的存储位置
- 链表
  - n 个结点由**指针链**组成一个链表
  - 它是线性表的链式存储映像，称为线性表的链式存储结构
- 单链表、双链表、循环链表
  - 结点只有一个指针域的链表，称为**单链表**或线性链表
  - 结点有两个指针域的链表，称为**双链表**
  - 首尾相接的链表称为**循环链表**
- 头指针、头结点和首元结点
  - 头指针：是指向链表中第一个结点的指针
  - 首元结点：是指链表中存储第一个数据元素$a_1$的结点
  - 头结点：是在链表的首元结点之前附设的一个结点

### 讨论
#### 如何表示空表
- 无头结点时，**头指针为空**时表示空表
- 有头结点时，**当头结点的指针域为空**时表示空表

#### 在链表中设置头结点有什么好处
- 便于**首元结点**的处理
  - 首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无须进行特殊处理
- 便于**空表和非空表**的统一处理
  - 无论链表是否为空，头指针都是指向头结点的非空指针，
  - 因此空表和非空表的处理也就统一了
- 头结点的**数据域**内装的是什么
  - 头结点的**数据域**可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值

### 链表特点
1. 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻
2. 访问时只能通过头指针进入链表，并通过每个结点的指针域**依次**向后顺序扫描其余结点

### 单链表
> 单链表是由**表头**唯一确定，因此单链表可以用**头指针**的名字来命名，若头指针名是 L，则把链表称为**表 L**

#### 定义
```c
    typedef struct Lnode {      // 声明结点的类型和指向结点的指针类型
        ElemType data;          // 结点的数据域
        struct Lnode *next;     // 结点的指针域
    } Lnode, *LinkList;         // LinkList 为指向结构体 Lnode 的指针类型
```
例子：
存储学生**学号、姓名、成绩**的单链表结点类型定义如下：
```c
    typedef struct student {
        char num[8];            // 数据域
        char name[8];           // 数据域
        int score;              // 数据域
        struct student *next;   // 指针域
    } Lnode, *LinkList;
```

**为了统一链表的操作，通常这样定义：**
```c
typedef struct {
    char num[8];            // 数据域
    char name[8];           // 数据域
    int score;              // 数据域
} ElemType;

typedef struct Lnode {
    ElemType data           // 数据域
    struct Lnode *next;     // 指针域
} Lnode, *LinkList;
```

#### 单链表基本操作的实现
##### 单链表的初始化（带头结点）

算法步骤：
1. 生成新结点作头结点，用头指针 L 指向头结点
2. 将头结点的指针域置空

算法描述：
```c
  Status InitList L(LinkList &L) {
    L = new Lnode; // 或 L = (LinkList) malloc(sizeof(LNode));
    L -> next = NULL;
    return OK;
  }
```

##### 判断链表是否为空
> 空表：链表中无元素，称为空链表（头指针和头结点仍然在）
> 思路：判断头结点指针域是否为空
```c
  int ListEmpty(LinkList L) { // 若 L 为空表，则返回 1，否则返回 0
    if(L -> next) // 非空
      return 0;
    else
      return 1;
  }
```

##### 销毁单链表
> 思路：从头指针开始，依次释放所有结点
> 先将指针指向下一个结点，再删除上一个结点
```c
  L = L -> next
  delete p;
  L == NULL // 循环条件
  L != NULL // 结束条件
```

```c
  Status DestoryList L(LinkList &L) { // 销毁单链表 L
    Lnode *p; // 或 LinkList p;
    while(L) {
      p = L;
      L = L -> next;
      delete p;
    }
    return OK;
  }
```

##### 清空链表
> 链表仍存在，但链表中无元素，成为空链表（头指针和头结点仍然在）
> 思路：依次释放所有结点，并将头结点指针域设置为空

```c
Status ClearList(LinkList &L) { // 将 L 重置为空表
  Lnode *p, &q;   // 或 LinkList p, q;
  p = L -> next;
  while(p) {
    q = p -> next;
    delete p;
    p = q;
  }
  L -> next = NULL;   // 头结点指针域为空
  return OK;
}
```

##### 求单链表的表长
> 思路：从首元结点开始，依次计数所有结点

```c
int ListLength L(LinkList L) { // 返回 L 中数据元素个数
  LinkList p; // or LNode *p;
  p = L -> next; // p 指向第一个结点 
  i = 0;
  while(p) {  // 遍历单链表，统计结点数
    i++;
    p = p -> next;
  }
  return i;
}
```

# 树
> 树（Tree）是 n($n \leq 0$) 个结点的**有限集**
- 若 n = 0，则称为**空树**
- 若 n > 0，则它满足以下两个条件：
    - 有且仅有一个特定的称为**根**（Root）的结点
    - 其余结点可分为 m($m \geq 0$) 个互不相交的有限集 T1, T2, T3, ..., Tm
        - 其中每一个集合本身又是一棵树，并称为根的**子树**（SubTree）
> 显然，树的定义是一个递归的定义    

## 基本术语
### 结点
> 数据元素以及指向子树的分支

### 根节点
> 非空树种无前驱结点的结点

### 结点的度
> 结点拥有的子树数

### 树的度
> 树内各节点的度的最大值

### 叶子结点
> 也称终端结点，度 = 0

### 分支结点
> 度 $\neq$ 0 ，非终端结点

### 内部结点
> 根节点以外的分支结点称为**内部结点**

### 孩子
> 结点的子树的根称为该结点的孩子

### 双亲
> 该结点称为孩子的双亲

### 兄弟
> 双亲是同一个的结点

### 堂兄弟
> 双亲在同一层的结点（不是同一个）

### 结点的祖先
> 从根到该结点所经分支上的所有结点

### 结点的子孙
> 以某结点为根的子树中的任一结点

### 树的深度
> 树中结点的最大层次

### 有序树
> 树中结点的各子树从左至右有次序（最左边的为第一个孩子）

### 无序树
> 树中结点的各子树无次序

### 森林
> m($m \geq 0$) 棵互不相交的树的集合
> 把一棵树的根节点删除后就变成了森林
> 将森林的各子树加上一个双亲结点，森林就变成了树

## 与线性结构的比较
| 线性结构 | 树结构 |
| --- | --- |
| 第一个数据元素 **无前驱** | 根节点（只有一个）**无双亲** |
| 最后一个数据元素 **无后继** | 叶子节点（可以有多个）**无孩子** |
| 其他数据元素 | 其他结点 - 中间结点 | 
| **一个前驱，一个后继** | **一个双亲，多个孩子** |
| **一对一** | **一对多** |

### 案例引入
#### 数据压缩问题
> 将数据文件转换成由 0, 1 组成的二进制串，称之为编码

a. 等长编码方案
| 字符 | 编码 |
| --- | --- |
| a | 00 |
| b | 01 |
| c | 10 |
| d | 11 |

b. 不等长编码方案1
| 字符 | 编码 |
| --- | --- |
| a | 0 |
| b | 10 |
| c | 110 |
| d | 111 |

c. 不等长编码方案2
| 字符 | 编码 |
| --- | --- |
| a | 0 |
| b | 01 |
| c | 010 |
| d | 111 |

> 之后用哈夫曼树实现

#### 利用二叉树求解表达式的值
> 以二叉树表示表达式的递归定义如下：
> 1. 若表达式为数或者简单变量，则相应二叉树中仅有一个根节点，其数据域存放该表达式信息
> 2. 若表达式为“**第一操作数 运算符 第二操作数**”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根节点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身又为表达式

## 二叉树
> 为何重点研究二叉树？
> - 二叉树的结构最简单，规律性最强
> - 可以证明，所有树都能转为唯一对应的二叉树，不失一般性
> 普通树（多叉树）若不转换为二叉树，则运算很难实现

**定义：**
> n($n \geq 0$) 个结点的有限集，它或者是空集（n = 0），或者由一个**根节点**及**两颗互不相交**的分别称作这个根的**左子树**和**右子树**的二叉树组成


**特点：**
1. 每个结点最多有两个孩子（**二叉树中不存在度大于 2 的结点**）
2. 子树有左右之分，其次序不能颠倒
3. 二叉树可以是空集合，根可以有空的左子树或空的右子树

> 注意：二叉树**不是**树的特殊情况，它们是两个概念
> - 二叉树结点的子树要区分**左子树**和**右子树**，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树
> - 当树结点只有一个孩子时，就**无需区分**它是左还是右的次序
> **这是二叉树和树最主要的差别**
> 虽然二叉树与树的概念不同，不过有关树的基本术语对二叉树都适用

### 5 种基本形态
- 空二叉树
- 根和空的左右子树
- 根和左子树
- 根和右子树
- 根和左右子树

### 抽象数据类型定义
ADT BinaryTree {
数据对象D：D 是具有相同特性的数据元素的集合
数据关系R：
- 若 $D = \empty$，则 $R = \empty$
- 若 $D \neq \empty$，则 $R = {H}$，H 是如下的二元关系
    - root 唯一 // 关于根的说明
    - $D_j \bigcap D_k = \empty$ // 关于子树不相交的说明
    - ... // 关于数据元素的说明
    - ... // 关于左子树和右子树的说明

基本操作P：
} ADT BinaryTree

### 二叉树的基本操作
#### CreateBiTree(&T, definition)
- 初始条件
    - definition 给出二叉树 T 的定义
- 操作结果
    - 按 definition 构造二叉树 T

#### PreOrderTraverse(T)
- 初始条件
    - 二叉树 T 存在
- 操作结果
    - 先序遍历 T，对每个结点访问一次

#### InOrderTraverse(T)
- 初始条件
    - 二叉树 T 存在
- 操作结果
    - 中序遍历 T，对每个结点访问一次
#### PostOrderTraverse(T)
- 初始条件
    - 二叉树 T 存在
- 操作结果
    - 后序遍历 T，对每个结点访问一次

### 二叉树的性质
#### 性质 1
> 在二叉树的第 i 层上**至多**有 $2^{i-1}$ 个结点（$i \geq 1$）

##### 证明
> 采用归纳法证明此性质
> - 归纳基：当 i = 1 时，只有一个根结点， $2^{i-1} = 2^0 = 1$，命题成立
> - 归纳假设：设对所有的$j(1 \leq j < i)$，命题成立，即第 j 层上至多有 $2^{j-1} 个结点，那么可以证明 j = i 时命题也成立$
> - 归纳证明：由归纳假设可知，第 i - 1 层上至多有 $2^{i-1}$ 个结点
> 由于二叉树每个结点的度最大为 2，故在第 i 层上最大结点数为第 i - 1 层上最大结点数的 2 倍，即：$2 * 2^{i-2} = 2^{i-1}$ 证毕

> 在二叉树的第 i 层上**至少**有 1 个结点（$i \geq 1$）

#### 性质 2
> 深度为 k 的二叉树**至多**有 $2^k - 1$ 个结点（$k \geq 1$）

##### 证明
> 由性质 1 可知，深度为 k 的二叉树的最大结点数为：
$\sum_{i=1}^{k}（第 i 层上的最大结点数）= \sum_{i=1}^{k}2^{i-1}$
> $=2^0 + 2^1 + ... + 2^{k-1}$
> $= \frac{2^0 - 2^{k-1} * 2}{1-2}$
> $= \frac{1-2^k}{-1}$
> $= 2^k-1$
证毕

> 等比数列求和公式
> $S_n = \frac{a_1-a_nq}{1-q}$
> $=\frac{a_1(1-q^n)}{1-q}(q \neq 1)$

> 深度为 k 的二叉树**至少**有 k 个结点（$k \geq 1$）


#### 性质 3
> 对任何一棵二叉树 T，如果其叶子数为 $n_0$，度为 2 的结点数为 $n_2$，则 $n_0 = n_2 + 1$

设总边数为：B
- 从下向上计算，每个结点对应一条边（除了根结点）
    - $B = n - 1$
- 从上向下计算，度为 2 的结点对应两条边，度为 1 的结点对应一条边
    - $B = n_2  * 2 + n_1 * 1$

设总结点数为：n
- $n = n_2 * 2 + n_1 * 1 + 1$，又 $n = n_2 + n_1 + n_0$
- 得 $n = n_2 + 1 = n_0$

> n_i：度为 i

### 满二叉树
> 一棵深度为 k 且又 $2^k - 1$ 个结点的二叉树称为**满二叉树**

**特点：**
1. 每一层上的结点数都是最大结点数（即**每层都满**）
2. 叶子结点全部在最底层

**对满二叉树结点位置进行编号**
- 编号规则：从根节点开始，**自上而下，自左而右**
- 每一结点位置都有元素

### 完全二叉树
> Complete binary tree 深度为 k 的具有 n 个结点的二叉树，当且仅当每一个结点都与深度为 k 的**满二叉树**中**编号**为 1~n 的结点**一一对应**时，称之为**完全二叉树**

> 注：在满二叉树中，从最后一个结点开始，**连续**去掉**任意**个结点，即是一棵完全二叉树

**特点：**
1. 叶子只可能分布在层次最大的两层上
2. 对任一结点，如果其右子树的层次为 i
    - 则其左子树的最大层次必为 i 或 i+1

#### 完全二叉树的性质
##### 性质 4
> 具有 n 个结点的完全二叉树的深度为 $[log_2n] + 1$
> 注：[x]：称为 x 的底，表示不大于 x 的最大整数
> $[log_2n]$ 在 $log_28$ ~ $log_216$ 之间（3 - 4）取 3

**证明：**
> 假设此二叉树的深度为 k，则根据性质 2 以及完全二叉树的定义得到：$2^{k-1}-1<n \leq 2^k-1$
> 或 $2^{k-1} \leq n < 2^k$
> 取对数得：$k-1 \leq log_2n < k$
> 因为 k 是整数，所以有：$k = [log_2n] + 1$

> 性质 4 表明了完全二叉树**结点数** n 与完全二叉树**深度** k 之间的关系

##### 性质 5
> 如果对一棵有 n 个结点的**完全二叉树**（深度为 $[log_2n]$ + 1）的结点按层序编号（从第 1 层到第 $[log_2n] + 1$）层，每层从左到右），则对**任一结点 i**（$i \leq i \leq n$），有：
> 1. 如果 i = 1，则结点 i 是二叉树的根，无双亲，如果 i > 1，则其**双亲是结点[i/2]**
> 2. 如果 2i > n，则结点 i 为叶子结点，无左孩子，否则，其**左孩子是结点 2i**
> 3. 如果 2i + 1 > n，则结点 i 无右孩子，否则，其**右孩子是结点 2i + 1**

> 性质 5 表明了完全二叉树中**双亲结点编号**与**孩子结点编号**之间的关系

### 存储结构
#### 顺序存储
> 实现：按**满二叉树**的结点层次编号，依次存放二叉树中的数据元素

```c
// 二叉树顺序存储表示
#define MAXTSIZE 100
Typedef TElemType SqBiTree[MAXTSIZE]
SqBiTree bt;
```

##### 顺序存储缺点
**最坏情况**：深度为 k 的且只有 k 个结点的单支树需要长度为 $2^k-1$ 的一维数组
| | | | | | |
| --- | --- | --- | --- | --- | --- |
| 1 | 0 | 2 | 0 | 0 | 0 | 3 |

**特点：**
- 结点间关系蕴含在其存储位置中
- 浪费空间，适于存储**满二叉树和完全二叉树**

#### 链式存储

##### 二叉链表
**结构：**
- data 数据域
- lchild 左孩子
- rchild 右孩子

```c
typedef struct BiNode {
    TElemType data;
    struct BiNode *lchild, *rchild; // 左右孩子指针
} BiNode, *BiTree;
```

> 在 n 个结点的二叉链表中，有多少个空指针域

> 分析：必有 **2n** 个链域，除根节点外，每个结点有且仅有一个双亲，所以只会有 **n - 1** 个结点的链域存放指针，指向非空子女结点
> 空指针数目 = $2n - (n - 1) = n + 1$

##### 三叉链表
**结构：**
- data 数据域
- parent 双亲
- lchild 左孩子
- rchild 右孩子

```c
typedef struct BiNode {
    TElemType data;
    struct BiNode *lchild, *rchild, *parent; // 左右孩子和双亲指针
} BiNode, *BiTree;
```

### 遍历二叉树
- 遍历定义
    - > 顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）
    - > “访问”的定义很广，可以是对结点作各种处理
- 遍历目的
    - 得到书中所有结点的一个线性排列
- 遍历用途
    - 它是树结构插入、删除、修改、查找和排序运算的前提


#### 算法描述

遍历方法：
> 依次遍历二叉树中的三个组成部分，便是遍历了整个二叉树
- 根节点
- 左子树
- 右子树

假设：
- L：遍历左子树
- D：访问根节点
- R：遍历右子树

则遍历二叉树有六种方案：
DLR, LDR, LRD, DRL, RDL, RLD

> 若规定**先左后右**，则只有前三种情况：
- DLR 先（根）序遍历
- LDR 中（根）序遍历
- LRD 后（根）序遍历

> 二叉树表示算术表达式
> 遍历结果
> - 先序：$-+a*b-cd/ef$
>   - 表达式的**前缀表示**（波兰式）
> - 中序：$a+b*c-d-e/f$
>   - 表达式的**中缀表示**
> - 后序：$abcd-*+ef/-$
>   - 表达式的**后缀表示**（逆波兰式）

#### 根据遍历序列确定二叉树
> 由二叉树的**先序序列和中序序列**，或由二叉树的**后序序列和中序序列**可以确定唯一一棵二叉树

##### 已知中序序列和先序序列求二叉树
例：已知二叉树的先序和中序序列，构造出相应的二叉树
- 先序：A B C D E F G H I J
- 中序：C D B F E A I H G J

分析：**由先序序列确定根，由中序序列确定左右子树**
解：
- 由先序知根为 A，则由中序知左子树为 CDBFE，右子树为 IHGJ
- 再分别从左、右子树的序列中找出根、左子树序列、右子树序列
- 依次类推，直到得到二叉树

##### 已知中序序列和后序序列求二叉树
- 中序：B D C E A F H G
- 后序：D E C B H G F A

> 注：**后序遍历，根结点必在后序序列尾部**


#### 递归算法遍历
> 以先序遍历为例
- 若二叉树为空，则空操作
- 若二叉树非空
    - 访问**根节点**（D）
    - 先序遍历**左子树**（L）
    - 先序遍历**右子树**（R）

**算法实现：**
```c
Status PreOrederTraverse(BiTree T) {
    if(T == NULL) return OK; // 空二叉树
    else {
        visit(T); // 访问根结点
        PreOrderTraverse(T -> lchild); // 递归遍历左子树
        PreOrderTraverse(T -> rchild); // 递归遍历右子树
    }
}
```

> 中序遍历和后序遍历同理

**遍历算法分析：**
- 时间效率：$O(n)$ 每个结点只访问一次
- 空间效率：$O(n)$ 栈占用的最大辅助空间

#### 非递归算法遍历
> 以中序遍历为例

> 二叉树**中序遍历的非递归算法的关键**：
> 中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树

**基本思想：**
1. 建立一个栈
2. 根结点进栈，遍历左子树
3. 根节点出栈，输出根结点，遍历右子树

**算法实现：**
```c
Status InOrderTraverse(BiTree T) {
    BiTree p; InitStack(S); p = T;
    while(p || !StackEmpty(S)) {
        if(p) {
            Push(S, p); p = p -> lchild;
        } else {
            Pop(S, q); printf("%c", q -> data);
            p = p -> rchild;
        }
    } // while
    return OK;
}
```

#### 层次遍历
> 从根结点开始，按**从上到下、从左到右**的顺序访问每一个结点
> 每个结点仅访问一次

**算法设计：**
> 使用一个**队列**
1. 将根结点进队
2. 队不空时循环，从队列中出列一个结点 *p，访问它
   1. 若它有左孩子结点，将左孩子结点进队
   2. 若它有右孩子结点，将右孩子结点进队

**算法实现：**
```c
typedef struct {
    BTNode data[MaxSize]; // 存放队中元素
    int front, rear; // 队头和队尾指针
} SqQueue; // 顺序循环队列类型

// 层次遍历算法
void LevelOrder(BTNode *b) {
    BTNode *p; SqQueue *qu;
    InitQueue(qu); // 初始化队列
    enQueue(qu, b); // 根结点指针进入队列
    while(!QueueEmpty(qu)) { // 队不为空，则循环
        deQueue(qu, p); // 出队结点 p
        printf("%c", p -> data); // 访问结点 p
        if(p -> lchild != NULL) enQueue(qu, p -> lchild); // 有左孩子时将其进队
        if(p -> rchild != NULL) enQueue(qu, p -> rchild); // 有右孩子时将其进队
    }
}
```

#### 二叉树遍历算法的应用

##### 二叉树的建立
> 按先序遍历序列建立二叉树的二叉链表

1. 从键盘输入二叉树的结点信息，建立二叉树的存储结构
2. 在建立二叉树的过程中**按照二叉树先序方式**建立
3. 当结点为空时用 # 表示

**算法实现：**
```c
Status CreateBiTree(BiTree *&T) {
    scanf(&ch); // cin >> ch;
    if(ch == "#") T = NULL;
    else {
        if(!(T = (BiTNode *)malloc(sizeof(BiTNode))))
            exit(OVERFLOW); // T = new BiTNode;
        T -> data = ch; // 生成根结点
        CreateBiTree(T -> lchild); // 构造左子树
        CreateBiTree(T -> rchild); // 构造右子树
    }
    return OK;
} // CreateBiTree
```

##### 复制二叉树

**算法设计：**
- 如果是空树，递归结束
- 否则，申请新结点空间，复制根结点
    - 递归复制左子树
    - 递归复制右子树

**算法实现：**
```c
int Copy(BiTree T, BiTree &NewT) {
    if(T == NULL) { // 如果是空树返回 0
        NewT = NULL; return 0;
    } else {
        NewT = new BiTNode; NewT -> data = T -> data;
        Copy(T -> lchild, NewT -> lchild);
        Copy(T -> rchild, NewT -> rchild);
    }
}
```

##### 计算二叉树深度

**算法设计：**
- 如果是空树，则深度为 0
- 否则，递归计算左子树的深度记为 m，递归计算右子树的深度记为 n，
    - 二叉树的深度则为 m 与 n 的较大者加 1

**算法实现：**
```c
int Depth(BiTree T) {
    if(T == NULL) return 0; // 如果是空树返回 0
    else {
        m = Depth(T -> lchild);
        n = Depth(T -> rchild);
        if(m > n) {
            return (m + 1);
        } else {
            return (n + 1);
        }
    }
}
```

##### 计算二叉树结点总数

**算法设计：**
- 如果是空树，则结点个数为 0
- 否则，结点个数为左子树的结点个数 + 右子树的结点个数再 + 1

**算法实现：**
```c
int NodeCount(BiTree T) {
    if(T == NULL)
        return 0;
    else
        return NodeCount(T -> lchild) + NodeCount(T -> rchild) + 1;
}
```

##### 计算二叉树叶子结点数

**算法设计：**
- 如果是空树，则叶子结点个数为 0
- 否则，为左子树的叶子结点数 + 右子树的叶子结点个数

**算法实现：**
```c
int LeafCount(BiTree T) {
    if(T == NULL) // 如果是空树返回 0
        return 0;
    if(T -> lchild == NULL && T -> rchild == NULL)
        return 1;
    else
        return LeafCount(T -> lchild) + LeafCount(T -> rchild);
}
```

### 线索二叉树

> 为什么要研究线索二叉树？
> 当用二叉链表作为二叉树的存储结构时，可以很方便地找到某个结点的左右孩子
> 但一般情况下，**无法直接找到该结点在某种遍历序列中的前驱和后继结点**

解决方案：
1. 通过遍历查找 > 浪费时间
2. 增设前驱、后继指针域 > 增加了存储负担
3. **利用二叉链表中的空指针域**（二叉链表中 n + 1 个空指针域 ）

**利用二叉链表中的空指针域：**
- 如果某个结点的左孩子为空，则将空的左孩子指针改为**指向其前驱**
- 如果某个结点的右孩子为空，则将空的右孩子指针改为**指向其后继**

> 这种**改变指向的指针**称为**线索**
> 添加了线索的二叉树称为**线索二叉树**（Threaded Binary Tree）
> 对二叉树按某种遍历次序使其变为线索二叉树的过程叫做**线索化**

> 为了区分 lchild 和 rchild 指针是指向孩子的指针，还是指向前驱或后继的指针
> 对二叉链表中**每个结点增设两个标志域** ltag, rtag

- ltag = 0 lchild 指向该结点的**左孩子**
- ltag = 1 lchild 指向该结点的**前驱**
- rtag = 0 rchild 指向该结点的**右孩子**
- rtag = 1 rchild 指向该结点的**后继**

**结点的结构：**
```c
typedef struct BiThrNode {
    int data;
    int ltag, rtag;
    struct BiThrNode *lchild, rchild;
} BiThrNode, *BiThrTree;
```

> 增设一个头结点
> 为避免结点的悬空态
> - ltag = 0，lchild 指向根结点
> - ltag = 1，rchild 指向遍历序列中最后一个结点
> 遍历序列中第一个结点的 lc 域和最后一个结点的 rc 域都指向头结点




# 树
> 树（Tree）是 n($n \leq 0$) 个结点的**有限集**
- 若 n = 0，则称为**空树**
- 若 n > 0，则它满足以下两个条件：
    - 有且仅有一个特定的称为**根**（Root）的结点
    - 其余结点可分为 m($m \geq 0$) 个互不相交的有限集 T1, T2, T3, ..., Tm
        - 其中每一个集合本身又是一棵树，并称为根的**子树**（SubTree）
> 显然，树的定义是一个递归的定义    

## 基本术语
### 结点
> 数据元素以及指向子树的分支

### 根节点
> 非空树种无前驱结点的结点

### 结点的度
> 结点拥有的子树数

### 树的度
> 树内各节点的度的最大值

### 叶子结点
> 也称终端结点，度 = 0

### 分支结点
> 度 $\neq$ 0 ，非终端结点

### 内部结点
> 根节点以外的分支结点称为**内部结点**

### 孩子
> 结点的子树的根称为该结点的孩子

### 双亲
> 该结点称为孩子的双亲

### 兄弟
> 双亲是同一个的结点

### 堂兄弟
> 双亲在同一层的结点（不是同一个）

### 结点的祖先
> 从根到该结点所经分支上的所有结点

### 结点的子孙
> 以某结点为根的子树中的任一结点

### 树的深度
> 树中结点的最大层次

### 有序树
> 树中结点的各子树从左至右有次序（最左边的为第一个孩子）

### 无序树
> 树中结点的各子树无次序

### 森林
> m($m \geq 0$) 棵互不相交的树的集合
> 把一棵树的根节点删除后就变成了森林
> 将森林的各子树加上一个双亲结点，森林就变成了树

## 与线性结构的比较
| 线性结构 | 树结构 |
| --- | --- |
| 第一个数据元素 **无前驱** | 根节点（只有一个）**无双亲** |
| 最后一个数据元素 **无后继** | 叶子节点（可以有多个）**无孩子** |
| 其他数据元素 | 其他结点 - 中间结点 | 
| **一个前驱，一个后继** | **一个双亲，多个孩子** |
| **一对一** | **一对多** |

### 案例引入
#### 数据压缩问题
> 将数据文件转换成由 0, 1 组成的二进制串，称之为编码

a. 等长编码方案
| 字符 | 编码 |
| --- | --- |
| a | 00 |
| b | 01 |
| c | 10 |
| d | 11 |

b. 不等长编码方案1
| 字符 | 编码 |
| --- | --- |
| a | 0 |
| b | 10 |
| c | 110 |
| d | 111 |

c. 不等长编码方案2
| 字符 | 编码 |
| --- | --- |
| a | 0 |
| b | 01 |
| c | 010 |
| d | 111 |

> 之后用哈夫曼树实现

#### 利用二叉树求解表达式的值
> 以二叉树表示表达式的递归定义如下：
> 1. 若表达式为数或者简单变量，则相应二叉树中仅有一个根节点，其数据域存放该表达式信息
> 2. 若表达式为“**第一操作数 运算符 第二操作数**”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根节点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身又为表达式

## 二叉树
> 为何重点研究二叉树？
> - 二叉树的结构最简单，规律性最强
> - 可以证明，所有树都能转为唯一对应的二叉树，不失一般性
> 普通树（多叉树）若不转换为二叉树，则运算很难实现

**定义：**
> n($n \geq 0$) 个结点的有限集，它或者是空集（n = 0），或者由一个**根节点**及**两颗互不相交**的分别称作这个根的**左子树**和**右子树**的二叉树组成


**特点：**
1. 每个结点最多有两个孩子（**二叉树中不存在度大于 2 的结点**）
2. 子树有左右之分，其次序不能颠倒
3. 二叉树可以是空集合，根可以有空的左子树或空的右子树

> 注意：二叉树**不是**树的特殊情况，它们是两个概念
> - 二叉树结点的子树要区分**左子树**和**右子树**，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树
> - 当树结点只有一个孩子时，就**无需区分**它是左还是右的次序
> **这是二叉树和树最主要的差别**
> 虽然二叉树与树的概念不同，不过有关树的基本术语对二叉树都适用

### 5 种基本形态
- 空二叉树
- 根和空的左右子树
- 根和左子树
- 根和右子树
- 根和左右子树

### 抽象数据类型定义
ADT BinaryTree {
数据对象D：D 是具有相同特性的数据元素的集合
数据关系R：
- 若 $D = \empty$，则 $R = \empty$
- 若 $D \neq \empty$，则 $R = {H}$，H 是如下的二元关系
    - root 唯一 // 关于根的说明
    - $D_j \bigcap D_k = \empty$ // 关于子树不相交的说明
    - ... // 关于数据元素的说明
    - ... // 关于左子树和右子树的说明

基本操作P：
} ADT BinaryTree

### 二叉树的基本操作
#### CreateBiTree(&T, definition)
- 初始条件
    - definition 给出二叉树 T 的定义
- 操作结果
    - 按 definition 构造二叉树 T

#### PreOrderTraverse(T)
- 初始条件
    - 二叉树 T 存在
- 操作结果
    - 先序遍历 T，对每个结点访问一次

#### InOrderTraverse(T)
- 初始条件
    - 二叉树 T 存在
- 操作结果
    - 中序遍历 T，对每个结点访问一次
#### PostOrderTraverse(T)
- 初始条件
    - 二叉树 T 存在
- 操作结果
    - 后序遍历 T，对每个结点访问一次

### 二叉树的性质
#### 性质 1
> 在二叉树的第 i 层上**至多**有 $2^{i-1}$ 个结点（$i \geq 1$）

##### 证明
> 采用归纳法证明此性质
> - 归纳基：当 i = 1 时，只有一个根结点， $2^{i-1} = 2^0 = 1$，命题成立
> - 归纳假设：设对所有的$j(1 \leq j < i)$，命题成立，即第 j 层上至多有 $2^{j-1} 个结点，那么可以证明 j = i 时命题也成立$
> - 归纳证明：由归纳假设可知，第 i - 1 层上至多有 $2^{i-1}$ 个结点
> 由于二叉树每个结点的度最大为 2，故在第 i 层上最大结点数为第 i - 1 层上最大结点数的 2 倍，即：$2 * 2^{i-2} = 2^{i-1}$ 证毕

> 在二叉树的第 i 层上**至少**有 1 个结点（$i \geq 1$）

#### 性质 2
> 深度为 k 的二叉树**至多**有 $2^k - 1$ 个结点（$k \geq 1$）

##### 证明
> 由性质 1 可知，深度为 k 的二叉树的最大结点数为：
$\sum_{i=1}^{k}（第 i 层上的最大结点数）= \sum_{i=1}^{k}2^{i-1}$
> $=2^0 + 2^1 + ... + 2^{k-1}$
> $= \frac{2^0 - 2^{k-1} * 2}{1-2}$
> $= \frac{1-2^k}{-1}$
> $= 2^k-1$
证毕

> 等比数列求和公式
> $S_n = \frac{a_1-a_nq}{1-q}$
> $=\frac{a_1(1-q^n)}{1-q}(q \neq 1)$

> 深度为 k 的二叉树**至少**有 k 个结点（$k \geq 1$）


#### 性质 3
> 对任何一棵二叉树 T，如果其叶子数为 $n_0$，度为 2 的结点数为 $n_2$，则 $n_0 = n_2 + 1$

设总边数为：B
- 从下向上计算，每个结点对应一条边（除了根结点）
    - $B = n - 1$
- 从上向下计算，度为 2 的结点对应两条边，度为 1 的结点对应一条边
    - $B = n_2  * 2 + n_1 * 1$

设总结点数为：n
- $n = n_2 * 2 + n_1 * 1 + 1$，又 $n = n_2 + n_1 + n_0$
- 得 $n = n_2 + 1 = n_0$

> n_i：度为 i

### 满二叉树
> 一棵深度为 k 且又 $2^k - 1$ 个结点的二叉树称为**满二叉树**

**特点：**
1. 每一层上的结点数都是最大结点数（即**每层都满**）
2. 叶子结点全部在最底层

**对满二叉树结点位置进行编号**
- 编号规则：从根节点开始，**自上而下，自左而右**
- 每一结点位置都有元素

### 完全二叉树
> Complete binary tree 深度为 k 的具有 n 个结点的二叉树，当且仅当每一个结点都与深度为 k 的**满二叉树**中**编号**为 1~n 的结点**一一对应**时，称之为**完全二叉树**

> 注：在满二叉树中，从最后一个结点开始，**连续**去掉**任意**个结点，即是一棵完全二叉树

**特点：**
1. 叶子只可能分布在层次最大的两层上
2. 对任一结点，如果其右子树的层次为 i
    - 则其左子树的最大层次必为 i 或 i+1

#### 完全二叉树的性质
##### 性质 4
> 具有 n 个结点的完全二叉树的深度为 $[log_2n] + 1$
> 注：[x]：称为 x 的底，表示不大于 x 的最大整数
> $[log_2n]$ 在 $log_28$ ~ $log_216$ 之间（3 - 4）取 3

**证明：**
> 假设此二叉树的深度为 k，则根据性质 2 以及完全二叉树的定义得到：$2^{k-1}-1<n \leq 2^k-1$
> 或 $2^{k-1} \leq n < 2^k$
> 取对数得：$k-1 \leq log_2n < k$
> 因为 k 是整数，所以有：$k = [log_2n] + 1$

> 性质 4 表明了完全二叉树**结点数** n 与完全二叉树**深度** k 之间的关系

##### 性质 5
> 如果对一棵有 n 个结点的**完全二叉树**（深度为 $[log_2n]$ + 1）的结点按层序编号（从第 1 层到第 $[log_2n] + 1$）层，每层从左到右），则对**任一结点 i**（$i \leq i \leq n$），有：
> 1. 如果 i = 1，则结点 i 是二叉树的根，无双亲，如果 i > 1，则其**双亲是结点[i/2]**
> 2. 如果 2i > n，则结点 i 为叶子结点，无左孩子，否则，其**左孩子是结点 2i**
> 3. 如果 2i + 1 > n，则结点 i 无右孩子，否则，其**右孩子是结点 2i + 1**

> 性质 5 表明了完全二叉树中**双亲结点编号**与**孩子结点编号**之间的关系

### 存储结构
#### 顺序存储
> 实现：按**满二叉树**的结点层次编号，依次存放二叉树中的数据元素

```c
// 二叉树顺序存储表示
#define MAXTSIZE 100
Typedef TElemType SqBiTree[MAXTSIZE]
SqBiTree bt;
```

##### 顺序存储缺点
**最坏情况**：深度为 k 的且只有 k 个结点的单支树需要长度为 $2^k-1$ 的一维数组
| | | | | | |
| --- | --- | --- | --- | --- | --- |
| 1 | 0 | 2 | 0 | 0 | 0 | 3 |

**特点：**
- 结点间关系蕴含在其存储位置中
- 浪费空间，适于存储**满二叉树和完全二叉树**

#### 链式存储

##### 二叉链表
**结构：**
- data 数据域
- lchild 左孩子
- rchild 右孩子

```c
typedef struct BiNode {
    TElemType data;
    struct BiNode *lchild, *rchild; // 左右孩子指针
} BiNode, *BiTree;
```

> 在 n 个结点的二叉链表中，有多少个空指针域

> 分析：必有 **2n** 个链域，除根节点外，每个结点有且仅有一个双亲，所以只会有 **n - 1** 个结点的链域存放指针，指向非空子女结点
> 空指针数目 = $2n - (n - 1) = n + 1$

##### 三叉链表
**结构：**
- data 数据域
- parent 双亲
- lchild 左孩子
- rchild 右孩子

```c
typedef struct BiNode {
    TElemType data;
    struct BiNode *lchild, *rchild, *parent; // 左右孩子和双亲指针
} BiNode, *BiTree;
```


# 查找

## 基本概念

### 在哪里找
> 查找表
> 是由同一类型的数据元素（或记录）构成的**集合**，由于“集合”中的数据元素之间存在着**松散的关系**
> 因此查找表是一种应用灵便的结构

### 如何查找
> 根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或记录
> 关键字
> 用来标识一个数据元素或记录的某个数据项的值
> - 主关键字
>   - 可以唯一地标识一个记录的关键字是主关键字
> - 次关键字
>   - 可以识别若干记录的关键字是次关键字

### 查找的目的
- 查询某个特定的数据元素是否在查找表中
- 查询某个特定的数据元素的各种属性
- 在查找表中插入一个数据元素
- 删除查找表中的某个数据元素

### 查找表分类
- 静态查找表
    - 仅做**查询**操作
- 动态查找表
    - 做**插入**和**删除**操作的查找表

### 查找算法的评价指标
- 关键自的平均比较次数，也称**平均查找长度**
- ASL(Average Search Length)
    - $ASL=\sum^n_{i=1}pici$ 关键字比较次数的期望值
      - n 记录的个数
      - pi 查找第 i 个记录的概率（通常认为 pi = 1/n）
      - ci 查找第 i 个记录所需的比较次数

## 线性表的查找
- 顺序查找（线性查找）
- 折半查找（二分或对分查找）
- 分块查找

### 顺序查找

#### 应用范围
- 顺序表或线性链表表示的**静态查找表**
- 表内元素之间**无序**

#### 数据元素类型定义
```c
typedef struct {
    KeyType key; // 关键字域
    ... // 其他域
} ElemType;

typedef struct { // 顺序表结构类型定义
    ElemType *R; // 表基址
    int length; // 表长
} SSTable; // Sequential Search Table
SSTable St;  // 定义顺序表 ST
```

#### 算法实现
```c
int Search_Seq(SSTable ST,, KeyType key) {
    // 若成功返回其位置信息，否则返回 0
    for(i = ST.length;i >= 1;--i) {
        if (ST.R[i].key == key) {
            return i;
        }
    }
    return 0;
}
```

其他形式
```c
int Search_Seq(SSTable St, KeyType key) {
    for(i = ST.length;ST.R[i].key != key && i > 0;--i);
    if(i > 0) return i;
    else return 0;
}
```

> 改进：将待查关键字 key 存入表头（“哨兵”，“监视哨”），从后向前逐个比较
> 可以免去查找过程中每一步都要检测是否查找完毕，加快速度

```c
int Search_Seq(SSTable ST, KeyType key) {
    ST.R[0].key = key;
    for(i = ST.length;ST.R[i].key != key;--i);
    return i;
}
```

> 当 ST.length 较大时，此改进能使进行一次查找所需的平均时间几乎减少一半

#### 算法性能分析

##### 时间效率
比较次数与 key 位置有关
- 查找第 i 个元素，需要比较 **n-i+1** 次
- 查找失败，需比较 n+1 次

> 查找成功的平均查找长度：
> - 设表中各记录查找概率相等（1/n）
> - $ASL_s(n)=(1+2+...+n)/n=(n+1)/2$

##### 空间复杂度
> 一个辅助空间 O(1)

#### 讨论
1. 记录的查找概率不相等时如何提高查找效率
查找表存储记录原则：按照查找概率高低存储
- 查找概率越高，比较次数越少
- 查找概率越低，比较次数越多

2. 记录的查找概率无法测定时如何提高查找效率
方法：按照查找概率动态调整记录顺序
- 在每个记录中设置一个访问频度域
- 始终保持记录按非递增有序的次序排列
- 每次查找后均将查找到的记录直接移至表头

#### 算法特点
- 优点
    - 算法简单，逻辑次序无要求，且不同存储结构均适用
- 缺点
    - ASL 太长，时间效率太低

### 折半查找

#### 非递归算法

**算法步骤**
- 设表长为 n, low, high, mid 分别指向待查元素所在区间的上界、下界和中点，key 为给定的要查找的值
- 初始时，令 low = 1, high = n, mid = (low + high) / 2
- k 与 mid 指向的记录比较
    - key == R[mid].key 查找成功
    - key < R[mid].key high = mid - 1
    - key > R[mid].key low = mid + 1
- 重复上述操作，直至 low > high 时，查找失败

**算法实现**
```c
int Search_Bin(SSTable ST, KeyType key) {
    low = 1; high = ST.length; // 设置区间初值
    while(low <= high) {
        mid = (low + high) / 2;
        if(ST.R[mid].key == key) return mid; // 找到待查元素
        else if(key < ST.R[mid].key) // 缩小查找区间
            high = mid - 1; // 继续在前半区间查找
        else
            low = mid + 1; // 继续在后半区间查找
    }
    return 0; // 顺序表中不存在待查元素
} // Search_Bin
```

#### 递归算法
```c
int Search_Bin(SSTable ST, KeyType key, int low, int high) {
    if(low > high) return 0; // 查找不到时返回 0
    mid = (low + high) / 2;
    if(key == St.elem[mid].key) return mid;
    else if(key < ST.elem[mid].key)
        return Search_Bin(ST, key, low, mid - 1); // 继续在前半区间查找
    }else if (key > ST.elem[mid].key){
        return Search_Bin(ST, key, mid + 1, high); // 继续在后半区间查找
    }
}
```

#### 算法性能分析

将查找的结点构成一个判定树（二叉树）
- 圆形
    - 内结点，代表查找成功
- 矩形
    - 外结点，代表查找失败
- 查找成功
    - 比较次数 = 路径上的结点数 = 结点的层数
    - 比较次数 <= 树的深度 = $log_2n+1$
- 查找失败
    - 比较次数 = 路径上的内部结点数 比较次数 <= $log_2n+1$
- 平均查找长度（成功时）
    - > 设表长 $n=2^h-1$，则 $h=log_2(n+1)$（此时，判定树为深度=h的满二叉树），且表中每个记录的查找概率相等：$P_i = 1 / n$
    - $ASL_{bs} = \sum^n_{i=1}P_ic_i=\frac{1}{n}\sum^n_i=1=\frac{1}{n}\sum^h_{j=1}j*2^{j-1}$
    - $\frac{n+1}{n}log_2(n+1)-1$
    - $\approx log_2(n+1)-1(n>50)$
    - > j：第 j 层的每个结点要比较的次数
    - > $2^{j-1}$：第 j 层要比较的总次数
- 优点
    - 效率比顺序查找高
- 缺点
    - 只适用于**有序表**，且限于**顺序存储结构**（对线性链表无效）

### 分块查找

#### 查找思路
- 将表分成几块，且表或者有序，或者**分块有序**
    - 若 i < j，则第 j 块中所有记录的关键字均大于第 i 块中的最大关键字
- 建立索引表（每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）
- 先确定待查记录所在快（顺序或折半），再再块内查找（顺序）


#### 算法的性能分析
- 查找效率：$ASL=L_b+L_w$
    - $l_b$ 对索引表查找的 ASL
    - $l_w$ 对块内查找的 ASL
- $ASL_{bs} \approx log_2(\frac{n}{s})+\frac{s}{2}$
- $log_2n \leq ASL_{bs} \leq \frac{n+1}{2}$
    - s 为每块内部的记录个数，n/s 即块的数目
- 优点
    - 插入和删除比较容易，无需进行大量移动
- 缺点
    - 需要增加一个索引表的存储空间并对初始索引表进行排序运算
- 适用情况
    - 如果线性表既要快速查找又经常动态变化，则可采用分块查找

### 查找方法比较
| | 顺序查找 | 折半查找 | 分块查找 |
| --- | --- | --- | --- |
| ASL | 最大 | 最小 | 中间 |
| 表结构 | 有序表、无序表 | 有序表 | 分块有序 |
| 存储结构 | 顺序表、线性链表 | 顺序表 | 顺序表、线性链表 |


## 树表的查找
> 当表插入、删除操作频繁时，为了维护表的有序性，需要移动表中很多记录
- **改用你动态查找表**（几种特殊的树）
- 表结构在**查找过程中动态生成**
- 对于给定值 key
    - 若表中存在，成功返回
    - 否则，插入关键字等于 key 的记录
- 特殊的树
    - 二叉排序树
    - 平衡二叉树
    - 红黑树
    - B-树
    - B+树
    - 键树

### 二叉排序树
> Binary Sort Tree 又称为二叉搜索树、二叉查找树

#### 定义
**二叉排序树**或是空树，或是满足如下性质的二叉树
1. 若其**左子树**非空，则左子树上所有结点的值均**小于根结点**的值
2. 若其**右子树**非空，则右子树上所有结点的值均**大于根结点**的值
3. 其**左右子树本身又各是一棵二叉排序树**

#### 性质
- 中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的**递增有序**序列

#### 算法思路
1. 若二叉排序树为空，则查找失败，返回空指针
2. 若二叉排序树非空，将给定值 key 与根结点的关键字
- T -> data.key 进行比较
    1. 若 key == T -> data.key，查找成功，返回根结点地址
    2. 若 key < T -> data.key，则进一步**查找左子树**
    3. 若 key > T -> data.key，则进一步**查找右子树**

#### 结构定义
```c
typedef struct {
    KeyType key; // 关键字项
    InfoType otherInfo; // 其他数据域
} ElemType;

typedef struct BSTNode {
    ElemType data; // 数据域
    struct BSTNode *lchild, *rchild; // 左右孩子指针
} BSTNode, *BSTree;

BSTree T; // 定义二叉排序树 T
```

#### 算法实现
```c
BSTree SearchBST(BSTree T, KeyType key) {
    if((!T) || key == T -> data.key) {
        return T;
    } else if (key < T -> data.key) {
        return SearchBST(T -> lchild, key); // 在左子树中继续查找
    } else {
        return SearchBST(T -> rchild, key); // 在右子树中继续查找
    }
} // SearchBST
```

#### 算法分析
> 二叉排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径
> - 比较的关键字次数 = 此结点所在层次数
> - 最多的比较次数 = 树的深度

- 含有 n 个结点的二叉排序树的**平均查找长度**和树的**形态**有关
- 最好情况
  - 初始序列 {45, 24, 53, 12, 37, 93}
    - $ASL=log_2(n+1)-1$
    - 树的深度为 $log_2n+1$ 与折半查找中的判定树相同（形态比较均衡）$O(log_2n)$
- 最坏情况
  - 初始序列 {12, 24, 37, 45, 53, 93} 插入的 n 个元素从一开始就有序 > 变成单支树的形态
    - 此时树的深度为 n $ASL=log_2(n+1)/2$
    - 查找效率与顺序查找情况相同：$O(n)$

#### 插入操作
- 若二叉树为空，则插入结点作为根结点插入到空树中
- 否则，继续在其左、右子树上查找
    - 树中已有，不再插入
    - 树中没有
        - 查找直至某个叶子结点的左子树或右子树为空位置，则插入结点应为该叶子结点的左孩子或右孩子
> 插入的元素一定在叶结点上

#### 生成操作
> 一个无序序列可通过构造二叉排序树而变成一个有序序列，构造树的过程就是对无序序列进行排序的过程
- 插入的结点均为叶子结点，故无需移动其他结点
- 相当于在有序序列上插入记录而无需移动其他记录
> 关键字的输入顺序不同，会建立不同的二叉排序树

#### 删除操作
> 从二叉排序树中删除一个结点，不能把以该结点为根的子树都删除，只能删除该结点，
> 并且**还应保证删除后所得的二叉树仍然满足二叉排序树的性质不变**
- 将因删除结点而断开的二叉链表重新链接起来
- 防止重新链接后树的高度增加

- 删除的结点是叶子结点
    - 直接删除该结点，双亲结点中相应指针域的值修改为空
- 删除的结点只有左子树或者只有右子树
    - 用其左子树或右子树替换它（结点替换）
    - 其双亲结点的相应指针域的值修改为 “指向被删除结点的左子树或右子树”
- 删除的结点既有左子树，也有右子树
    - 两种方案
        - 以其中序前趋值替换之（值替换），然后再删除该前趋结点，**前趋是左子树中最大的结点**
        - 以其中序后继值替换之（值替换），然后再删除该后继结点，**后继是右子树中最小的结点**

### 平衡二叉树
> 提高形态不均衡的二叉排序树的查找效率
- balanced binary tree
- 又称 AVL 树（Adelson-Velskii and Landis）
- 一棵平衡二叉树或者是空树，或者是具有下列性质的**二叉排序树**
    - 左子树与右子树的高度之差的绝对值小于等于 1
    - 左子树和右子树也是平衡二叉排序树
- 为了方便起见，为每个结点附加一个数字，给出**该结点左子树和右子树的高度差**
  - 这个数字被称为**平衡因子**(BF)
  - 平衡因子 = 结点左子树的高度 - 结点右子树的高度
  - 所有结点的平衡因子只能是 -1, 0, 1
- 对于一棵有**n**个结点的AVL树，其高度保持在 $O(log_2n)$ 数量级
    - ASL 也会保持在 $O(log_2n)$ 数量级
- $n_h$ 个结点且高度为 h 的平衡二叉树最少结点数：$n_h = n_{h-1}  + n_{h-2} + 1$


#### 失衡二叉排序树的分析与调整
- 四种类型
    - LL 型
    - LR 型
    - RL 型
    - RR 型
- A：失衡结点（不止一个失衡节点时，为最小失衡子树的根结点）
- B：A 结点的孩子 C 结点的双亲
- C：插入新结点的子树
- 调整原则
    - 降低高度
    - 保持二叉排序树性质

## 散列表的查找

### 散列表概念
- 基本思想：记录的存储位置与关键字之间存在对应关系
    - 对应关系：hash 函数 Loc(i) = H(keyi)

### 散列表术语

#### 散列方法
- 选取某个函数，根据该函数按关键字**计算元素的存储位置**，并按此存放
- 查找时，**由同一函数对给定值 k 计算地址**，将 k 与地址单元中元素关键码进行对比，确定是否查找成功

#### 散列函数
- 散列方法中使用的**转换函数**

#### 散列表
- 按上述思想构造的表

#### 冲突
- 不同的关键码映射到同一个散列地址
- 不可避免，只能尽可能减少

#### 同义词
- 具有相同函数值的多个关键字

### 如何查找
> 根据散列函数 H(key) = k 查找
- 优点：查找效率高
- 缺点：空间效率低

### 散列函数的构造

#### 需要解决的问题
- 构造好的散列函数
    - 所选函数尽可能简单，以便提高转换速度
    - 所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费
- 指定一个好的解决冲突的方案
    - 查找时，如果从散列函数计算出的地址中查找不到关键码
        - 应当依据解决冲突的规则，有规律地查询其他相关单元

#### 构造散列函数需要考虑的因素
1. 执行速度（即计算散列函数所需时间）
2. 关键字的长度
3. 散列表的大小
4. 关键字的分布情况
5. 查找频率

#### 构造方法
> 根据元素集合的特性构造
- 要求一：n 个数据原仅占用 n 个地址，虽然散列表时以空间换时间 ，但仍希望散列的**地址空间尽量小**
- 要求二：无论用什么方法存储，目的都是尽量**均匀**地存放元素，以避免冲突
- 五种方法
    - 直接定址法
    - 数字分析法
    - 平方取中法
    - 折叠法
    - **除留余数法**
    - 随机数法

##### 直接定址法
> Hash(key) = a.key + b (a, b 为常数)
- 优点
    - 以关键码 key 的某个线性函数 值为散列地址，不会产生冲突
- 缺点
    - 要占用连续地址空间，空间效率低

##### 除留余数法
> Hash(key) = key mod p （p 是一个整数）
- 关键：如何选取合适的 p
- 设表长为 m，取 p <= m 且为质数

#### 处理冲突
- 四种方法
    - **开放定址法（开地址法）**
    -  链地址法（拉链法）
    - 再散列法（双散列函数法）
    - 建立一个公共溢出区

##### 开放定址法

**基本思想**
> 有冲突时就去寻找**下一个**空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入

**常用方法**
- 线性探测法
- 二次探测法
- 伪随机探测法

###### 线性探测法
- $H_i$  = (Hash(key)) + $d_i$) mod m (1 <= i < m)
- m：散列表长度
- $d_i$：增量序列 1, 2, ...m-1，且 $d_i=i$
- 一旦冲突，就找下一个地址，直到找到空地址存入


###### 二次探测法
- $H_i$  = (Hash(key)) + $d_i$) mod m
- m：散列表长度，要求是某个 4k+3 的质数
- $d_i$：增量序列 $1^2,-1^2,2^2,-2^2,...,q^2$

###### 伪随机探测法
- $H_i$  = (Hash(key)) + $d_i$) mod m (1 <= i < m)
- m：散列表长度
- $d_i$；伪随机数

##### 链地址法

**基本思想**
> 相同散列地址的记录链成一单链条
> **m 个散列地址就设 m 个单链表**，然后用一个数组将 m 个单链表的表头指针存储起来，形成一个动态的结构

**步骤**
1. Step1：取数据元素的关键字 key，计算器散列函数值（地址），若该地址对应的链表为空，则将该元素插入此链表，否则执行 step2 解决冲突
2. Step2：根据选择的冲突处理方法，计算关键字 key 的下一个存储地址，若该地址对应的链表不为空，则利用链表的前插法或后插法将该元素插入此链表

**特点**
- 非同义词不会冲突，无“聚集”现象
- 链表上结点空间动态申请，更适合于表长不确定的情况

### 散列表的查找效率分析
- 平均查找长度 ASL 取决于
    - 散列函数
    - 处理冲突的方法
    - 散列表的**装填因子**$\alpha = \frac{表中填入的记录数}{哈希表的长度}$ 
        - $\alpha$ 越大，表中记录数越多，发生冲突可能性越大，查找比较次数越多
- ASL 与装填 $\alpha$ 有关，既不是严格的 $O(1)$，也不是 $O(n)$
    - 拉链法 $ASL \approx 1 + \frac{\alpha}{2}$
    - 线性探测法 $ASL \approx \frac{1}{2}( 1+\frac{1}{1-\alpha})$
    - 随机探测法 $ASL \approx -\frac{1}{\alpha}ln(1-aplha)$
- 总结
    - 散列表计数具有很好的平均性能，优于一些传统的技术
    - 链地址法优于开地址法
    - 除留余数法作散列函数优于其他类型函数


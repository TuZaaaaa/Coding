# 查找

## 基本概念

### 在哪里找
> 查找表
> 是由同一类型的数据元素（或记录）构成的**集合**，由于“集合”中的数据元素之间存在着**松散的关系**
> 因此查找表是一种应用灵便的结构

### 如何查找
> 根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或记录
> 关键字
> 用来标识一个数据元素或记录的某个数据项的值
> - 主关键字
>   - 可以唯一地标识一个记录的关键字是主关键字
> - 次关键字
>   - 可以识别若干记录的关键字是次关键字

### 查找的目的
- 查询某个特定的数据元素是否在查找表中
- 查询某个特定的数据元素的各种属性
- 在查找表中插入一个数据元素
- 删除查找表中的某个数据元素

### 查找表分类
- 静态查找表
    - 仅做**查询**操作
- 动态查找表
    - 做**插入**和**删除**操作的查找表

### 查找算法的评价指标
- 关键自的平均比较次数，也称**平均查找长度**
- ASL(Average Search Length)
    - $ASL=\sum^n_{i=1}pici$ 关键字比较次数的期望值
      - n 记录的个数
      - pi 查找第 i 个记录的概率（通常认为 pi = 1/n）
      - ci 查找第 i 个记录所需的比较次数

## 线性表的查找
- 顺序查找（线性查找）
- 折半查找（二分或对分查找）
- 分块查找

### 顺序查找

#### 应用范围
- 顺序表或线性链表表示的**静态查找表**
- 表内元素之间**无序**

#### 数据元素类型定义
```c
typedef struct {
    KeyType key; // 关键字域
    ... // 其他域
} ElemType;

typedef struct { // 顺序表结构类型定义
    ElemType *R; // 表基址
    int length; // 表长
} SSTable; // Sequential Search Table
SSTable St;  // 定义顺序表 ST
```

#### 算法实现
```c
int Search_Seq(SSTable ST,, KeyType key) {
    // 若成功返回其位置信息，否则返回 0
    for(i = ST.length;i >= 1;--i) {
        if (ST.R[i].key == key) {
            return i;
        }
    }
    return 0;
}
```

其他形式
```c
int Search_Seq(SSTable St, KeyType key) {
    for(i = ST.length;ST.R[i].key != key && i > 0;--i);
    if(i > 0) return i;
    else return 0;
}
```

> 改进：将待查关键字 key 存入表头（“哨兵”，“监视哨”），从后向前逐个比较
> 可以免去查找过程中每一步都要检测是否查找完毕，加快速度

```c
int Search_Seq(SSTable ST, KeyType key) {
    ST.R[0].key = key;
    for(i = ST.length;ST.R[i].key != key;--i);
    return i;
}
```

> 当 ST.length 较大时，此改进能使进行一次查找所需的平均时间几乎减少一半

#### 算法性能分析

##### 时间效率
比较次数与 key 位置有关
- 查找第 i 个元素，需要比较 **n-i+1** 次
- 查找失败，需比较 n+1 次

> 查找成功的平均查找长度：
> - 设表中各记录查找概率相等（1/n）
> - $ASL_s(n)=(1+2+...+n)/n=(n+1)/2$

##### 空间复杂度
> 一个辅助空间 O(1)

#### 讨论
1. 记录的查找概率不相等时如何提高查找效率
查找表存储记录原则：按照查找概率高低存储
- 查找概率越高，比较次数越少
- 查找概率越低，比较次数越多

2. 记录的查找概率无法测定时如何提高查找效率
方法：按照查找概率动态调整记录顺序
- 在每个记录中设置一个访问频度域
- 始终保持记录按非递增有序的次序排列
- 每次查找后均将查找到的记录直接移至表头

#### 算法特点
- 优点
    - 算法简单，逻辑次序无要求，且不同存储结构均适用
- 缺点
    - ASL 太长，时间效率太低

### 折半查找

#### 非递归算法

**算法步骤**
- 设表长为 n, low, high, mid 分别指向待查元素所在区间的上界、下界和中点，key 为给定的要查找的值
- 初始时，令 low = 1, high = n, mid = (low + high) / 2
- k 与 mid 指向的记录比较
    - key == R[mid].key 查找成功
    - key < R[mid].key high = mid - 1
    - key > R[mid].key low = mid + 1
- 重复上述操作，直至 low > high 时，查找失败

**算法实现**
```c
int Search_Bin(SSTable ST, KeyType key) {
    low = 1; high = ST.length; // 设置区间初值
    while(low <= high) {
        mid = (low + high) / 2;
        if(ST.R[mid].key == key) return mid; // 找到待查元素
        else if(key < ST.R[mid].key) // 缩小查找区间
            high = mid - 1; // 继续在前半区间查找
        else
            low = mid + 1; // 继续在后半区间查找
    }
    return 0; // 顺序表中不存在待查元素
} // Search_Bin
```

#### 递归算法
```c
int Search_Bin(SSTable ST, KeyType key, int low, int high) {
    if(low > high) return 0; // 查找不到时返回 0
    mid = (low + high) / 2;
    if(key == St.elem[mid].key) return mid;
    else if(key < ST.elem[mid].key)
        return Search_Bin(ST, key, low, mid - 1); // 继续在前半区间查找
    }else if (key > ST.elem[mid].key){
        return Search_Bin(ST, key, mid + 1, high); // 继续在后半区间查找
    }
}
```

#### 算法性能分析

将查找的结点构成一个判定树（二叉树）
- 圆形
    - 内结点，代表查找成功
- 矩形
    - 外结点，代表查找失败
- 查找成功
    - 比较次数 = 路径上的结点数 = 结点的层数
    - 比较次数 <= 树的深度 = $log_2n+1$
- 查找失败
    - 比较次数 = 路径上的内部结点数 比较次数 <= $log_2n+1$
- 平均查找长度（成功时）
    - > 设表长 $n=2^h-1$，则 $h=log_2(n+1)$（此时，判定树为深度=h的满二叉树），且表中每个记录的查找概率相等：$P_i = 1 / n$
    - $ASL_{bs} = \sum^n_{i=1}P_ic_i=\frac{1}{n}\sum^n_i=1=\frac{1}{n}\sum^h_{j=1}j*2^{j-1}$
    - $\frac{n+1}{n}log_2(n+1)-1$
    - $\approx log_2(n+1)-1(n>50)$
    - > j：第 j 层的每个结点要比较的次数
    - > $2^{j-1}$：第 j 层要比较的总次数
- 优点
    - 效率比顺序查找高
- 缺点
    - 只适用于**有序表**，且限于**顺序存储结构**（对线性链表无效）

### 分块查找

#### 查找思路
- 将表分成几块，且表或者有序，或者**分块有序**
    - 若 i < j，则第 j 块中所有记录的关键字均大于第 i 块中的最大关键字
- 建立索引表（每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）
- 先确定待查记录所在快（顺序或折半），再再块内查找（顺序）


#### 算法的性能分析
- 查找效率：$ASL=L_b+L_w$
    - $l_b$ 对索引表查找的 ASL
    - $l_w$ 对块内查找的 ASL
- $ASL_{bs} \approx log_2(\frac{n}{s})+\frac{s}{2}$
- $log_2n \leq ASL_{bs} \leq \frac{n+1}{2}$
    - s 为每块内部的记录个数，n/s 即块的数目
- 优点
    - 插入和删除比较容易，无需进行大量移动
- 缺点
    - 需要增加一个索引表的存储空间并对初始索引表进行排序运算
- 适用情况
    - 如果线性表既要快速查找又经常动态变化，则可采用分块查找

### 查找方法比较
| | 顺序查找 | 折半查找 | 分块查找 |
| --- | --- | --- | --- |
| ASL | 最大 | 最小 | 中间 |
| 表结构 | 有序表、无序表 | 有序表 | 分块有序 |
| 存储结构 | 顺序表、线性链表 | 顺序表 | 顺序表、线性链表 |


## 树表的查找
> 当表插入、删除操作频繁时，为了维护表的有序性，需要移动表中很多记录
- **改用你动态查找表**（几种特殊的树）
- 表结构在**查找过程中动态生成**
- 对于给定值 key
    - 若表中存在，成功返回
    - 否则，插入关键字等于 key 的记录
- 特殊的树
    - 二叉排序树
    - 平衡二叉树
    - 红黑树
    - B-树
    - B+树
    - 键树

### 二叉排序树
> Binary Sort Tree 又称为二叉搜索树、二叉查找树

#### 定义
**二叉排序树**或是空树，或是满足如下性质的二叉树
1. 若其**左子树**非空，则左子树上所有结点的值均**小于根结点**的值
2. 若其**右子树**非空，则右子树上所有结点的值均**大于根结点**的值
3. 其**左右子树本身又各是一棵二叉排序树**

#### 性质
- 中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的**递增有序**序列

#### 算法思路
1. 若二叉排序树为空，则查找失败，返回空指针
2. 若二叉排序树非空，将给定值 key 与根结点的关键字
- T -> data.key 进行比较
    1. 若 key == T -> data.key，查找成功，返回根结点地址
    2. 若 key < T -> data.key，则进一步**查找左子树**
    3. 若 key > T -> data.key，则进一步**查找右子树**

#### 结构定义
```c
typedef struct {
    KeyType key; // 关键字项
    InfoType otherInfo; // 其他数据域
} ElemType;

typedef struct BSTNode {
    ElemType data; // 数据域
    struct BSTNode *lchild, *rchild; // 左右孩子指针
} BSTNode, *BSTree;

BSTree T; // 定义二叉排序树 T
```

#### 算法实现
```c
BSTree SearchBST(BSTree T, KeyType key) {
    if((!T) || key == T -> data.key) {
        return T;
    } else if (key < T -> data.key) {
        return SearchBST(T -> lchild, key); // 在左子树中继续查找
    } else {
        return SearchBST(T -> rchild, key); // 在右子树中继续查找
    }
} // SearchBST
```

#### 算法分析
> 二叉排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径
> - 比较的关键字次数 = 此结点所在层次数
> - 最多的比较次数 = 树的深度

- 含有 n 个结点的二叉排序树的**平均查找长度**和树的**形态**有关
- 最好情况
  - 初始序列 {45, 24, 53, 12, 37, 93}
    - $ASL=log_2(n+1)-1$
    - 树的深度为 $log_2n+1$ 与折半查找中的判定树相同（形态比较均衡）$O(log_2n)$
- 最坏情况
  - 初始序列 {12, 24, 37, 45, 53, 93} 插入的 n 个元素从一开始就有序 > 变成单支树的形态
    - 此时树的深度为 n $ASL=log_2(n+1)/2$
    - 查找效率与顺序查找情况相同：$O(n)$

#### 插入操作
- 若二叉树为空，则插入结点作为根结点插入到空树中
- 否则，继续在其左、右子树上查找
    - 树中已有，不再插入
    - 树中没有
        - 查找直至某个叶子结点的左子树或右子树为空位置，则插入结点应为该叶子结点的左孩子或右孩子
> 插入的元素一定在叶结点上

#### 生成操作
> 一个无序序列可通过构造二叉排序树而变成一个有序序列，构造树的过程就是对无序序列进行排序的过程
- 插入的结点均为叶子结点，故无需移动其他结点
- 相当于在有序序列上插入记录而无需移动其他记录
> 关键字的输入顺序不同，会建立不同的二叉排序树

#### 删除操作
> 从二叉排序树中删除一个结点，不能把以该结点为根的子树都删除，只能删除该结点，
> 并且**还应保证删除后所得的二叉树仍然满足二叉排序树的性质不变**
- 将因删除结点而断开的二叉链表重新链接起来
- 防止重新链接后树的高度增加

- 删除的结点是叶子结点
    - 直接删除该结点，双亲结点中相应指针域的值修改为空
- 删除的结点只有左子树或者只有右子树
    - 用其左子树或右子树替换它（结点替换）
    - 其双亲结点的相应指针域的值修改为 “指向被删除结点的左子树或右子树”
- 删除的结点既有左子树，也有右子树
    - 两种方案
        - 以其中序前趋值替换之（值替换），然后再删除该前趋结点，**前趋是左子树中最大的结点**
        - 以其中序后继值替换之（值替换），然后再删除该后继结点，**后继是右子树中最小的结点**

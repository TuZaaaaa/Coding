# 哈夫曼树

> 判断树：用于描述分类过程的二叉树

## 基本概念

### 树的路径长度
> 从**树根**到每一个结点的**路径长度之和**，记作：TL
> 结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树

### 权
> weight 权重，将树中结点赋给一个有着某种含义的数值，则这个数值称为该**结点的权**

### 结点的带权路径长度
> 从**根结点**到该结点之间的**路径长度**与该结点的**权**的**乘积**

### 树的带权路径长度
> 树中所有**叶子结点**的**带权路径长度之和**
> 记作：$WPL = \sum_{k=1}^{n}w_kl_k$ Weighted Path Length
> - $w_k$ 权值
> - $l_k$ 结点到根的路径长度

### 哈夫曼树
> 最优树 带权路径长度（WPL）最短的树
> 最优二叉树 带权路径长度（WPL）最短的二叉树

## 哈夫曼树的构造算法

> 贪心算法
> 构造哈夫曼树时首先选择权值小的叶子结点

### 哈夫曼算法
> 构造哈夫曼树的方法

1. 根据 n 个给定的权值 $\{w_1, w_2, ..., w_n\}$ 构成 n 棵二叉树的森林 $F=\{T_1, T_2, .., T_n\}$，其中 $T_i$ 只有一个带权为 $w_i$ 的根结点
> **构造森林全是根**

2. 在 F 中选取两棵根结点的权值最小的树作为左右子树，构造成一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和
> **选用两小造新树**

3. 在 F 中删除这两棵树，同时将新得到的二叉树加入森林中
> **删除两小添新人**

4. 重复 2 和 3，直到森林中只有一棵树位置，这棵树即为哈夫曼树
> **重复 2、3 剩单根**

总结：
- 哈夫曼树的结点度数为 0 或 2，没有度为 1 的结点
- 包含 n 个叶子结点的哈夫曼树中共有 (n + n-1) 2n-1 个结点（度为 0 + 度为 2）
- 包含 n 棵树的森林要经过 n-1 次合并才能形成哈夫曼树，共产生 n-1 个新结点

#### 哈夫曼算法实现
- 采用顺序存储结构，一维结构数组 HufmanTree H;

**结构类型定义：**
```c
typedef struct {
    int weight;
    int parent, lch, rch;
} HTNode, *HuffmanTree;
```

**算法步骤：**
1. 初始化 HT[1...2n-1]: `lch = rch = parent = 0;`
2. 输入初始 **n 个叶子结点**，置 HT[1...**n**] 的 **weight 值**
3. **进行以下 n-1 次合并**，依次产生 n-1 个结点 HT[i], i = n+1...2n-1;
    - 在 HT[i..i-1] 中选两个**未被选过**（从 parent == 0 的结点中选）的 weight 最小的两个结点**HT[s1]**和**HT[s2]**，**s1, s2 为两个最小结点下标**
    - 修改 HT[s1] 和 HT[s2] 的 parent 值：
        - `HT[s1].parent = i;`
        - `HT[s2].parent = i;`
    - 修改新产生的 HT[i]
        - `HT[i].weight =  HT[s1].weight + HT[s2].weight`
        - `HT[i].lch = s1; HT[i].rch = s2;`

**代码实现：**

```c
// 构造哈夫曼树
void CreateHuffmanTree(HuffmanTree HT, int n) {
    if(n <= 1) return;
    m = 2 * n - 1; // 数组共 2n - 1 个元素
    HT = new HTNode[m + 1]; // 0 号单元未用，HT[m] 表示根结点
    for(i = 1;i <= m;++i) { // 将 2n-1 个元素的 lch, rch, parent 置为 0
        HT[i].lch = 0;
        HT[i].rch = 0;
        HT[i].parent = 0;
    }
    for(i = 1;i <= n;++i) {
        cin >> HT[i].weight; // 输入前 n 个元素的 weight 值
    }

    // 建立哈夫曼树
    for(i = n + 1;i <= m;i++) { // 合并产生 n-1 个结点
        // 在 HT[k](i <= k <= i-1) 中选择两个其双亲域为 0
        // 且权值最小的结点，并返回它们在 HT 中的序号 s1 和 s2
        Select(HT, i-1, s1, s2);

        // 从 F 中删除 s1, s2
        HT[s1].parent = i; HT[s2].parent = i;
        // s1, s2 分别作为 i 的左右孩子
        HT[i].lch = s1; HT[i].rch = s2;
        // i 的权值为左右孩子权值之和
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
}

```

## 哈夫曼编码

> 在远程通讯中，要将待传字符转换成由二进制的字符串
> 设要传送的字符为：
> 若编码为：
> - A - 00
> - B - 01
> - C - 10
> - D - 11
> 若将编码设计为长度不等的二进制编码，
> 即让待传字符串中**出现次数较多的字符采用尽可能端的编码**，则转换的二进制字符串便可能减少

**设计长度不等的编码**
> 必须使任一字符的编码都**不是**另一个字符的编码的**前缀**（前缀编码），否则会**重码**

### 设计思路
> 问题：如何设计前缀码使得电文总长最短

1. **统计**字符集中**每个字符**在电文中**出现**的平均**概率**（概率越大，要求编码越短）
2. 利用哈夫曼树的特点：权越大的叶子离根越近，**将每个字符的概率值作为权值，构造哈夫曼树**，则概率越大的结点，路径越短
3. 在哈夫曼树的每个分支上标注 0 或 1
   1. 结点的**左分支标 0，右分支标 1**
   2. 把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的**字符的编码**

### 两个问题
#### 为什么哈夫曼编码能够保证使前缀编码？
> 因为没有一片树叶使另一片树叶的祖先，所以每个叶结点的编码就不可能是其他叶结点编码的前缀

#### 为什么哈夫曼编码能够保证字符编码总长最短？
> 因为哈夫曼树的带权路径长度最短，故字符编码的总长最短
- 性质 1 哈夫曼编码是前缀码
- 性质 2 哈夫曼编码是最优前缀码

### 算法实现

```c
void CreateHuffmanCode(HuffmanTree HT, HuffmanCode &HC, int n) {
    // 从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表 HC 中
    HC = new char * [n + 1]; // 分配 n 个字符编码的头指针矢量
    cd = new char[n]; // 分配临时存放编码的动态数组空间
    cd[n-1] = '\0\; // 编码结束符
    for(i = 1;i <= n;++i) { // 逐个字符求哈夫曼编码
        start = n = 1; c = i; f = HT[i].parent;
        while(f != 0) { // 从叶子结点开始向上回溯，直到根结点
            --start; // 回溯一次 start 向前指一个位置
            if(HT[f].lchild == c) cd[start] = '0'; // 结点 c 是 f 的左孩子，生成代码 0
            else cd[start] = '1'; // 结点 c 是 f 的右孩子，生成代码 1
            c = f; f = HT[f].parent; // 继续向上回溯
        } // 求出第 i 个字符的编码
        HC[i] = new char[n - start]; // 为第 i 个字符串编码分配空间
        strcpy(HC[i], &cd[start]); // 将求得的编码从临时空间 cd 复制到 HC 的当前行中
    }
    delete cd; // 释放临时空间
} // CreateHuffmanCode
```

### 文件的编码和译码

#### 编码
1. 输入各自符以及其权值
2. 构造哈夫曼树 HT[i]
3. 进行哈夫曼编码 HC[i]
4. 查找 HC[i]，得到各字符的哈夫曼编码

#### 解码
1. 构造哈夫曼树
2. 依次读入二进制码
3. 读入 0，则走向左孩子，读入 1，则走向右孩子
4. 一旦到达某叶子时，即可译出字符
5. 然后从根出发继续译码，指导结束



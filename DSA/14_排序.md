# 排序

## 概述
> 将一组杂乱无章的数据按一定规律顺次排列起来
> 即，将无序序列**排成一个有序序列**的运算
> 如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言

### 分类
- 存储介质
    - 内部排序和外部排序
- 比较器个数
    - 串行排序和并行排序
- 主要操作
    - 比较排序和基数排序
- 辅助空间
    - 原地排序和非原地排序
- 稳定性
    - 稳定排序和非稳定排序
- 自然性
    - 自然排序和非自然排序

#### 存储介质
- 内部排序
    - 数据量不大、数据在**内存**，无需内外存交换数据
- 外部排序
    - 数据量较大、数据在**外存（文件排序）**
- > 外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外村，显然外部排序要复杂得多

#### 比较器个数
- 串行排序：单处理机（同一时刻比较一对元素）
- 并行排序：多处理机（同一时刻比较多[对元素）

#### 主要操作
- 比较排序：用比较的方法
    - 插入排序、交换排序、选择排序、归并排序
- 基数排序
    - 不比较元素的大小，仅仅根据元素本身的取值确定其有序位置

#### 辅助空间
- 原地排序：辅助空间用量为 $O(1)$ 的排序方法（所占的辅助存储空间与参与排序的数据量大小无关）
- 非原地排序：辅助空间用量超过 $O(1)$ 的排序方法

#### 稳定性
- 稳定排序：能够使任何数值相等的元素，排序以后相对次序不变
- 非稳定性排序：不是稳定排序的方法
- 排序的稳定性只对**结构类型数据**排序有意义

#### 自然性
- 自然排序：输入数据越有序，排序的速度越快
- 非自然排序：不是自然排序


### 存储结构
> 记录序列以顺序表存储
```c
#define MAXSIZE 20 // 设记录不超过 20 个
typedef int KyeType; // 设关键字为整型（int 型）

Typedef struct { // 定义每个记录（数据元素）的结构
    KeyType key; // 关键字
    Infotype otherinfo; // 其他数据项
} RedType; // Record Type

Typedef struct { // 定义顺序表的结构
    RedType r[MAXSIZE + 1]; // 存储顺序表的向量 r[0] 一般作哨兵或缓冲区
    int length; // 顺序表的长度
} SqList;
```




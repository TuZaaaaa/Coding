# 排序

## 概述
> 将一组杂乱无章的数据按一定规律顺次排列起来
> 即，将无序序列**排成一个有序序列**的运算
> 如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言

### 分类
- 存储介质
    - 内部排序和外部排序
- 比较器个数
    - 串行排序和并行排序
- 主要操作
    - 比较排序和基数排序
- 辅助空间
    - 原地排序和非原地排序
- 稳定性
    - 稳定排序和非稳定排序
- 自然性
    - 自然排序和非自然排序

#### 存储介质
- 内部排序
    - 数据量不大、数据在**内存**，无需内外存交换数据
- 外部排序
    - 数据量较大、数据在**外存（文件排序）**
- > 外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序要复杂得多

#### 比较器个数
- 串行排序：单处理机（同一时刻比较一对元素）
- 并行排序：多处理机（同一时刻比较多对元素）

#### 主要操作
- 比较排序：用比较的方法
    - 插入排序、交换排序、选择排序、归并排序
- 基数排序
    - 不比较元素的大小，仅仅根据元素本身的取值确定其有序位置

#### 辅助空间
- 原地排序：辅助空间用量为 $O(1)$ 的排序方法（所占的辅助存储空间与参与排序的数据量大小无关）
- 非原地排序：辅助空间用量超过 $O(1)$ 的排序方法

#### 稳定性
- 稳定排序：能够使任何数值相等的元素，排序以后相对次序不变
- 非稳定性排序：不是稳定排序的方法
- 排序的稳定性只对**结构类型数据**排序有意义

#### 自然性
- 自然排序：输入数据越有序，排序的速度越快
- 非自然排序：不是自然排序


### 存储结构
> 记录序列以顺序表存储
```c
#define MAXSIZE 20 // 设记录不超过 20 个
typedef int KyeType; // 设关键字为整型（int 型）

Typedef struct { // 定义每个记录（数据元素）的结构
    KeyType key; // 关键字
    Infotype otherinfo; // 其他数据项
} RedType; // Record Type

Typedef struct { // 定义顺序表的结构
    RedType r[MAXSIZE + 1]; // 存储顺序表的向量 r[0] 一般作哨兵或缓冲区
    int length; // 顺序表的长度
} SqList;
```

## 插入排序

**基本思想**
- 边插入边排序，保证子序列中随时都是排好序的

**基本操作：有序插入**
- 在有序序列中插入一个元素，保持序列有序，有序长度不断增加
- 起初，a[0] 是长度为 1 的子序列，然后，逐一将 a[1] 至 a[n-1] 插入到有序子序列中

**插入方法**
- 在插入 a[i] 前，数组 a 的**前半段（a[0]-a[i-1]）是有序段，后半段（a[i]-a[n-1]）是**停留于输入次序的**无序段**
- 插入 a[i] 使 a[0]-a[i-1] 有序，也就是**要为 a[i] 找到有序位置 j**（0 <= j <= i）,将 a[i] 插入在 a[j] 的位置上

### 排序方法
- 直接插入排序
    - 顺序法 定位插入位置
- 二分插入排序
    - 二分法 定位插入位置
- 希尔排序
    - 缩小增量 多遍插入排序

### 直接插入排序
> 采用**顺序查找**法查找插入位置
1. 复制插入元素 `x = a[i];`
2. 记录后移，查找插入位置
    ```c
    for(j = i - 1;j >= 0 && x <a[j];j--) {
        a[j + 1] = a[j];
    }
    ```
3. 插入到正确位置 `a[j - 1] = x;`


#### 改进
- 设置**哨兵**
1. 复制为哨兵 `L.r[0] = L.r[i]`
2. 记录后移，查找插入位置
    ```c
    for(j = i - 1;L.r[0].key < L.r[j].key;--j) {
        L.r[j + 1] = L.r[j];
    }
    ```
3. 插入到正确位置 `L.r[j + 1] = L.r[0];`


#### 算法实现

```c
void InsertSort(SqList &L) {
    int i, j;
    for (i = 2;i <= L.length;++i) {
        if (L.r[i].key < L.r[i - 1].key) { // 将 L.r[i] 插入到有序子表
            L.r[0] = L.r[i]; // 复制为哨兵
            for (j = i - 1;L.r[0].key < L.r[j].key;--j) {
                L.r[j + 1] = L.r[j]; // 记录后移
            }
            L.r[j + 1] = L.r[0]; // 插入到正确位置
        }
    }
}
```

#### 算法性能分析
- 实现排序的基本操作
    - 比较序列中两个关键字的大小
    - 移动记录

##### 最好的情况
- 关键字在记录序列中**顺序有序**
- 比较的次数：$\sum^n_{i=2}1 = n - 1$
- 移动的次数：0

##### 最坏的情况
- 关键字在记录序列中**逆序有序**
- 比较的次数：$\sum^n_{i=2}i=\frac{(n+2)(n-1)}{2}$
- 移动的次数：$\sum^n_{i=2}(i+1)=\frac{(n+4)(n-1)}{2}$

##### 平均的情况
- 比较的次数：$\sum^{n-1}_{i=2}\frac{i+1}{2}=\frac{1}{4}(n+2)(n-1)$
- 移动的次数：$\sum^n_{i=2}(\frac{i+1}{2}+1)=\frac{1}{4}(n+6)(n-1)$

##### 时间复杂度结论
- 原始数据越接近有序，排序速度越快
- 最好情况下（输入数据是顺序的）$Tw(n)=O(n)$
- 最坏情况下（输入数据是逆序的）$Tw(n)=O(n^2)$
- 平均情况下，耗时大概是最坏情况的一半 $Te(n)=)(n^2)$

### 折半插入排序
- 查找插入位置时，采用折半查找法

#### 算法实现
```c
void BInsertSort(SqList &L) {
    for (i = 2;i <= L.length;++i) { // 依次插入第 2 ~ 第 n 个元素
        L.r[0] = L.r[i]; // 当前插入元素存到哨兵位置
        low = 1; hight = i - 1; // 采用二分查找法查找插入位置
        while (low <= high) {
            mid = (low + high) / 2;
            if (L.r[0].key < L.r[mid].key) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        } // 循环结束，high + 1 为插入位置
        for (j = i - 1;j >= high + 1;--j) {
            L.r[j + 1] = L.r[j]; // 移动元素
        }
        L.r[hight + 1] = L.r[0]; // 插入到正确的位置
    }
} // BInsertSort
```

#### 算法分析
- 关键码的比较次数与待排序对象序列的初始排列无关，仅依赖于对象个数
    - 在插入第 i 个对象时，需要经过 $log_2i + 1$ 次关键码比较，才能确定它应插入的位置
    - 当 n 较大时，总关键码比较次数比直接插入排序的最坏情况要好很多，但比其最好情况要差
    - 在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少
- 折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列
    - **减少了比较次数，但没有减少移动次数**
    - 平均性能优于直接插入排序
    - 时间复杂度：$O(n^2)$
    - 空间复杂度：$O(1)$
    - 是一种稳定的排序方法


### 希尔排序

#### 基本思想
> 先将整个待排记录序列分割成**若干子序列**，分别进行**直接插入排序**，待整个序列中的记录**基本有序**时，再对全体记录进行一次直接插入排序
> - 缩小增量
> - 多遍插入排序

#### 算法思路
- 定义增量序列 $D_k:D_M > D_{M-1} > ... > D_1 = 1$
- 对每个 $D_k$ 进行 $D_k$ 间隔 插入排序（k = M, M - 1, ...1）

#### 算法特点
- 一次移动，移动位置较大，跳跃式地接近排序后的最终位置
- 最后一次只需要少量移动
- 增量序列必须是递减的 ，最后一个必须是 1
- 增量序列应该是互质的

#### 算法实现
```c
void ShellSort(Sqlist &L, int dlta[], int t) {
    // dk 值依次存放在 dlta[t]
    // 按增量序列 dlta[0..t-1] 对顺序表 L 作希尔排序
    for (k = 0;k < t;++k) {
        ShellInsert(L, dlta[k]); // 一次增量为 dlta[k] 的插入排序
    }
} // ShellSort

void ShellInsert(SqList &L, int dk) {
    // 对顺序表 L 进行一次增量为 dk 的 Shell 排序，dk 为步长因子
    for (i = dk + 1;i <= L.length;++i) {
        if(r[i].key < r[i - dk].key) {
            r[0] = r[i];
            for (j = i - dk;j > 0 && (r[0].key < r[j].key);j = j -dk) {
                r[j + dk] = r[j];
            }
            r[j + dk] = r[0];
        }
    }
}
```

#### 算法分析
> 希尔排序算法效率与**增量序列的取值**有关
- Hibbard 增量序列
    - $D_k=2^{k-1}$ 相邻元素互质
    - 最坏情况：$T_{worst}=O(n^{3/2})$
    - 猜想：$T_{avg}=O(n^{5/4})$
- Sedgewick 增量序列
    - {1, 5, 19, 41, 109, ...}
        - $9*4^i-9*2^i+1$ 或 $4^i-3*2^i+1$
    - 猜想：$T_{avg}=O(n^{7/6})$ $T_{worst}=O(n^{4/3})$
- 时间复杂度是 n 和 d 的函数
    - $O(n^{1.25}) ~ O(1.6n^{1.25})$ 经验公式
- 空间复杂度：$O(1)$
- 是一种**不稳定**的排序算法
- 如果选择最佳 d 序列，目前**尚未解决**
    - 最后一个增量值**必须为 1**，因无除了 1 之外的公因子
    - **不宜在链式存储结构**上实现


## 交换排序

**基本思想**
> 两两比较，如果发生逆序则交换，直到所有记录都排好序为止

**常见的交换排序**
- 冒泡排序
- 快速排序


### 冒泡排序

#### 基本思想
> 每趟不断将记录两两比较，并按**前小后大**的规则交换
> - n 个记录，总共需要 n - 1 趟
> - 第 m 趟需要比较 n - m 趟

#### 算法实现
```c
void bubble_sort (SqList &L) { // 冒泡排序算法
    int m, i, j; RedType x; // 交换时临时存储
    for (m = 1;m <= n - 1;m++) { // 总共需 m 趟
        for (j = 1;j <= n - m;j++) {
            if (L.r[j].key > L.r[j + 1].key) { // 发生逆序
                x = L.r[j];
                L.r[j] = L.r[j + 1];
                L.r[j + 1] = x; // 交换
            } // endif
        }
    } // for
}
```

> 优点
> 每趟结束后，不仅能使一个最大值到最后面位置，还能同时部分理顺其他元素

#### 改进
> 一旦**某一趟比较时不出现记录交换，说明已经排好序了**，便可以结束算法

```c
void bubble_sort (SqList &L) { // 改进的冒泡排序算法
    int m, i, j, flag = 1; RedType x; // flag 作为是否有交换的标记
    for (m = 1;m <= n - 1 && flag == 1;m++) {
        flag = 0;
        for (j = 1;j <= m;j++) {
            if (L.r[j.key > L.r[j + 1].key]) { // 发生逆序
                flag = 1; // 发生交换，flag 为 1
                x = L.r[j];
                L.r[j] = L.r[j + 1];
                L.r[j + 1] = x; // 交换
            } // endif
        }
    } // for
}
```

#### 算法分析
- 时间复杂度
    - 最好情况（正序）
        - 比较次数：n - 1
        - 移动次数：0
    - 最坏情况（逆序）
        - 比较次数：$\sum^{n-1}_{i=1}(n-i)=\frac{1}{2}(n^2-n)$
        - 移动次数：$3\sum^{n}_{i=1}(n-i)=\frac{3}{2}(n^2-n)$
    - **最好**时间复杂度：$O(n)$
    - **最坏**时间复杂度：$O(n^2)$
    - **平均**时间复杂度：$O(n^2)$
    - 需要增加一个辅助空间 temp，辅助空间为 $S(n)=O(1)$
    - 冒泡排序是**稳定**的

### 快速排序

#### 基本思想
- 任取一个元素**为中心**（pivot：枢轴、中心点）
- 所有比它**小**的元素一律前放，比它**大**的元素一律后方
    - 形成**左右两个子表**
- 对各子表重新选择中心元素并**依此规则调整**（递归思想）
- 直到每个子表的元素**只剩一个**

#### 算法实现
```c
void main () {
    QSort(L, 1. L.length);
}

void QSort(SqList &L, int low, int high) {
    if (low <high) { // 长度大于 1
        pivotloc = Partition(L, low, high);
        // 将 L.r[low...high] 一分为二，pivotloc 为枢轴元素排好序的位置
        QSort(L, low, pivotloc - 1); // 对低子表递归排序
        QSort(L, pivotloc + 1, high); // 对高子表递归排序
    } // endif
} // QSort

int Partition(SqList &L, int low, int high) {
    L.r[0] = L.r[low];
    pivotkey = L.r[low].key;
    while (low < high) {
        while (low < high && L.r[high].key >= pivotkey) {
            --high;
        }
        while (low < high && L.r[low].key <= pivotkey) {
            ++low;
        }
    }
    L.r[low] = L.r[0];

    return low;
}
```

#### 算法分析
- 时间复杂度
    - 平均复杂度：$O(nlog_2n)$
        - Qsort(): $O(log_2n)$
        - Partition(): $O(log_2n)$
- 空间复杂度
    - 快速排序不是原地排序
    - 由于使用递归，需要递归调用栈的支持（即使不使用递归，也需要用户栈）
    - 平均情况下：需要 $O(log_n)$ 的栈空间
    - 最坏情况下：栈空间可达 $O(n)$
- 是一种**不稳定**的排序算法
- **快速排序不适于对原本有序或基本有序的记录序列进行排序**
- **划分元素的选取**是影响时间性能的关键
- **不是自然排序**的算法


## 选择排序

### 简单选择排序

#### 基本思想
> 在待排序的数据中选出最大（小）的元素放在其最终的位置

#### 基本操作
1. 首先通过 **n-1** 次关键字比较，从 **n** 个记录比较中找出关键字最小的记录，将它与第一个记录交换
2. 再通过 **n-2** 次比较，从剩余的 **n-1** 个记录中找出关键字次小的记录，将它与第二个记录比较
3. 重复上述操作，共进行 **n-1** 趟排序后，排序结束

#### 算法实现
```c
void SelectSort(SqList &K) {
    for (i = 1;i < L.length;++i) {
        k = i;
        for (j = i + 1;j <= L.length;j++) {
            if (L.r[j].key < L.r[k].key) {
                k = j; // 记录最小值位置
            }
        }
        if (k != i) {
            L.r[i] <--> L.r[k]; // 交换
        }
    }
}
```

#### 算法分析
- 时间复杂度
    - 记录移动次数
        - 最好情况：0
        - 最坏情况：3(n-1)
    - 比较次数
        - 无论待排序序列什么状态，比较次数都相同
        - $\sum^{n-1}_{i=1}(n-i)=\frac{n}{2}(n-1)$
- **不稳定**

### 堆排序

#### 堆的定义
> 若 n 个元素的序列 $\{a_1, a_2, ..., a_n\}$ 满足
> - $a_i \leq a_{2i}$
> - $a_i \leq a_{2i+1}$
> 或
> - $a_i \geq a_{2i}$
> - $a_i \geq a_{2i+1}$
> 分别称为**小根堆**和**大根堆**
> 堆实质是满足如下性质的**完全二叉树**
> - 二叉树中任一非叶子结点均小于（大于）它的孩子结点

#### 基本思想
> 若在输出**堆顶**的最小值（最大值）后，使得剩余 n-1 个元素的序列又建成一个堆，则得到 n 个元素次小值（次大值）...
> 如此反复，便能得到一个有序序列
> 需要解决两个问题
> - 如何由一个无序序列建成一个堆
> - 如何在输出堆顶元素后，调整剩余元素为一个新的堆

#### 堆的调整
1. 输出堆顶元素之后，以堆中**最后一个元素替代之**
2. 然后将根结点值与左、右子树的根结点值进行比较，并与其中**小者**进行**交换**
3. 重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为**筛选**

##### 算法实现
```c
void HeapAdjust (elem R[], int s, int m) {
    // 已知 R[s..m] 中记录的关键字除 R[s] 之外均满足堆的定义
    // 本函数调整 R[s] 的关键字，使 R[s..m] 成为一个大根堆
    rc = R[s];
    for (j = 2 * s;j <= m;j *= 2) { // 沿 key 较大的孩子结点向下筛选
        if (j < m && R[j] < R[j + 1]) [ // j 为 key 较大的记录的下标
            ++j;
        ]
        if (rc >= R[j]) {
            break;
        }
        R[s] = R[j];
        s = j; // rc 应插入在位置 s 上
    } // for
    R[s] = rc; // 插入
} // HeapAdjust
```


#### 堆的建立
> - 单结点的二叉树是堆
> - 完全二叉树中所有以叶子结点（序号 i > n / 2）为根的子树是堆
> - 我们只需依次将以序号为 **n/2, n/2-1, ... 1** 的结点为根的子树均调整为堆即可


##### 算法实现
```c
for (i = n / 2;i >= 1;i--) {
    HeapAdjust(R, i, n);
}
```

#### 排序的算法实现
```c
void HeapSort (elem R[]) { // 对 R[1] 到 R[n] 进行堆排序
    int i;
    for (i = n / 2;i >= 1;i--) {
        HeapAdjust(R, i, n); // 建初始堆
    }
    for (i = n;i > 1;i--) { // 进行 n-1 趟排序
        Swap(R[1], R[i]); // 根与最后一个元素交换
        HeapAdjust(R, 1, i - 1); // 对 R[1] 到 R[i-1] 重新建堆
    }
} // HeapSort
```

#### 算法分析
- 初始堆所需时间不超过 $O(n)$
- 排序阶段
    - 一个重新堆化所需时间不超过 $O(log_n)$
    - n-1 次循环所需时间不超过 $O(nlog_n)$
    - $Tw(n) = O(n) + O(nlog_n) = O(nlog_n)$
- 在最坏情况下，其时间复杂度也为 $O(nlog_2n)$
- 仅需一个记录大小供交换用的辅助存储空间
- **不稳定**
- 不适用待排序个数较少


## 归并排序

### 基本思想
> 将两个或两个以上的有序子序列**归并**为一个有序序列
> - 在内部排序中，通常采用的是**2-路归并排序**
> 即：将两个位置相邻的有序子序列 R[I..m] 和 R[m + 1..n] 归并为一个有序序列 R[I..n]

### 算法思路
- 设 R[low]-R[mid] 和 R[mid+1]-R[high] 相邻
- 归并为一个有序序列 R1[low]-R1[high]
- 若 SR[i].key <= SR[j].key
    - 则 TR[k] = RS[i]; k++; j++;
    - 否则 TR[k] = SR{j]; k++; j++;
> 整个归并排序仅需 $log_2n$ 趟

### 算法分析
- 时间效率：$O(nlog_2n)$
- 空间效率：$O(n)$ （需要一个与原始序列同样大小的辅助序列）
- **稳定**

## 基数排序

### 基本思想
> 分配 + 收集
> 也叫**桶排序**或**箱排序**：设置若干箱子，将关键字为 k 的记录放入第 k 个箱子，然后按序号将非空的连接

### 基本思路
> 设置是个箱子（0-9），依次按个、十、百进行排序

### 算法分析
- 时间效率：$O(k*(n+m))$
    - k：关键字个数
    - m：关键字取值范围为 m 个值
- 空间效率：$O(n+m)$
- **稳定**

## 各排序算法比较

### 时间性能
- 时间复杂度：$O(nlog_n)$
    - 快速排序、堆排序和归并排序，其中以快速排序为最好
- 时间复杂度：$O(n^2)$
    - 直接插入排序、冒泡排序和简单选择排序，其中以直接插入为最好
- 时间复杂度：$O(n)$
    - 基数排序

### 空间性能
> 排序过程中所需的辅助空间大小
1. 所有的简单排序方法（直接插入、冒泡、简单选择）和堆排序的空间复杂度为 $O(1)$
2. 快速排序为 $O(log_n)$，为栈所需的辅助空间
3. 归并排序所需辅助空间最多，其空间复杂度为 $O(n)$
4. 链式基数排序需附设队列首尾指针，则空间复杂度为 $O(rd)$

### 稳定性能
- 当对多关键字的记录序列进行  LSD 方法排序时，必须采用稳定的排序
- 快速排序和堆排序时不稳定的

### 时间复杂度下限
- 除基数排序外，其他方法都是基于比较关键字进行排序的排序方法
    - 可以证明，这类排序最快时间复杂度为 $O(nlog_n)$
- 可以用一棵判定树来描述这类基于比较关键字进行排序的排序算法

> 对应下标 i < j，arr[i] > arr[j]，则称 (i,j) 是一对**逆序对**
> 交换两个元素正好消除 1 个逆序对
> 定理1：任意 N 个不同元素组成的序列平均具有 N(N-1)/4 个逆序对
> 定理2：任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为 $O(n^2)$
> 结论：为了提高效率，需要每次消除不止一个逆序对

### 图示
| 类别 | 算法 | 时间最优 | 时间最劣 | 时间平均 | 空间 | 稳定性 |
| --- | --- | --- | --- | --- | --- | --- |
| 插入 | 直接插入 | $O(n)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定 |
| 插入 | 希尔 | $O(n)$ | $O(n^2)$ | ~$O(n^{1.3})$ | $O(1)$ | 不稳定 |
| 交换 | 冒泡 | $O(n)$ | $O(n^2)$ | ~$O(n^2)$ | $O(1)$ | 稳定 |
| 交换 | 快速 | $O(nlog_n)$ | $O(n^2)$ | $O(nlog_n)$ | $O(nlog_n)$ | 不稳定 |
| 选择 | 直接选择 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 不稳定 |
| 选择 | 堆 | $O(nlog_n)$ | $O(nlog_n)$ | $O(nlog_n)$ | $O(n^2)$ | 不稳定 |
| 归并 | 归并 | $O(nlog_n)$ | $O(nlog_n)$ | $O(nlog_n)$ | $O(n)$ | 稳定 |
| 基数 | 基数 | $O(n+m)$ | $O(k*(n+m))$ | $O(k*(n+m))$ | $O(n+m)$ | 稳定 |

> - k：待排元素的维数
> - m：基数的个数


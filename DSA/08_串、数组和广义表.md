# 串、数组和广义表
> 可以理解为 内容受限的线性表，严格来说，已不属于线性结构
## 串
> 串（String） 零个或多个任意**字符组成的有限序列**

- $S = "a_1, a_2, ..., a_n" n \geq 0$
    - 串名：S
    - 串值：$a_1, a_2, ...$
    - 串长：n
    - 空串：n = 0 用 $\emptyset$ 表示

### 几个术语
#### 子串
> 一个串中任意个连续字符组成的**子序列**（含空串）称为该串的子串
> **真子串**是指不包含自身的所有子串

例："abcde" 子串
    - "", "a", "ab", "abc", "abcd", "abcde" 等

#### 主串
> 包含子串的串相应地称为**主串**

#### 字符位置
> 字符**在序列中的序号**为该字符在串中的位置

#### 子串位置
> **子串第一个字符**在主串中的位置

#### 空格串
> 由一个或多个空格组成的串，**与空串不同**

#### 串相等
> 当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是**相等**的
> **所有空串都是相等的**

### 案例引入
#### 病毒感染检测
> 研究者将人的 DNA 和病毒的 DNA 均表示成由一些字母组成的字符串序列
> 检测某种病毒 DNA 序列是否在患者的 DNA 序列中出现过，如果出现过，则此人感染力该病毒，否则 没有感染

例：假设病毒的 DNA 序列为 baa，患者 1 的 DNA 序列为 aaabbba，则感染，患者 2 的 DNA 序列为 babbba，则未感染

> 注意，人的 DNA 序列时线性的，而病毒的 DNA 序列是环状的

### 类型定义
ADT String {
    数据对象：$D = {a_i | a_i \in CharacterSet, i = 1, 2, ..., n, n \geq 0}$
    数据关系：$R_1 = {< a_{i-1}, a_i> | a_{i-1}, a_i \geq D, i = 1, 2, ..., n}$
    基本操作：
        - Strlength(&T, chars); // 串赋值
        - Strcompare(S, T); // 串比较
        - StrLength(S); // 求串长
        - Concat(&T, S1, S2); // 串连结
        - SubString(&Sub, S, pos, len); // 求子串
        - StrCopy(&T, S); // 串拷贝
        - StrEmpty(S); // 串判空
        - ClearString(&S); // 清空串
        - **Index(S, T, pos);** // 子串的位置
        - Replace(&S, T, V); // 串替换
        - StrInsert(&S, pos, T); // 子串插入
        - StrDelete(&S, pos, len); // 子串删除
        - DestoryString(&S); // 串销毁
} ADT String

### 串的顺序存储结构
```c
#define MAXLEN 255
typedef struct {
    char ch[MAXLEN + 1]; // 存储串的一维数组
    int length; // 串的当前长度
} SString
```

### 串的链式存储结构
- 优点：操作方便
- 缺点：存储密度较低
- 可将多个字符放在一个结点中，以克服其缺点

#### 块链结构
```c
#define CHUNKSIZE 80 // 块的大小可由用户定义
typedef struct Chunk {
    char ch[CHUNKSIZE];
    struct Chunk *next;
} Chunk;

typedef struct {
    Chunk *head, *tail; // 串的头指针和尾指针
    int curlen; // 串的当前长度
} LString;  // 字符串的块链结构
```

### 串的操作
#### 串的模式匹配算法
> 确定**主串**中所含**子串**（模式串）第一次出现的位置（定位）

- 算法应用
    - 搜索引擎
    - 拼写检查
    - 语言翻译
    - 数据压缩

- 算法种类
    - BF 算法（Brute-Force，又称古典的，经典的，朴素的，穷举的）
    - KMP 算法（特点：速度快）

##### BF 算法
> Brute-Force 亦称简单匹配算法，采用穷举法的思路

**设计思想：**

`Index(S, T, pos)`
- 将主串的第 pos 个字符和模式串的第一个字符比较
  - 若相等，继续逐个比较后续字符
  - 若不等，从主串的下一字符起，重新与模式串的第一个字符比较
  - 直到主串的一个**连续子串序列**与模式串相等
    - 返回值为 S 中与 T 匹配的子序列第一个字符的序号，即匹配成功
  - 否则，匹配失败，返回值 0

**算法实现：**
```c
int Index_BF(SString S, SString T, int pos) {
    int i = pos, j = 1;
    while(i <= S.length && j <= T.length) {
        if(s.ch[i] == t.ch[j]) { // 主串和子串依次匹配下一字符
            ++i;
            ++j;
        } else { // 主串、子串指针回溯重新开始下一次匹配
            i = i - j + 2;
            j = 1;
        }
    }
    if(j >= T.length) {
        return i - T.length; // 返回匹配的第一个字符的下标
    } else {
        return 0; // 匹配不成功
    }
}
```

**时间复杂度：**
若 n 为主串长度，m 为子串长度，最坏情况：
- 主串前面 n - m 个位置都部分匹配到子串的最后一位
  - 即这 n - m 各比较了 m 次
- 最后 m 位也各比较了 1 次

> 总次数为：$(n - m) * m + m = (n - m + 1) * m$
> 如果 $m << n$，则算法时间复杂度为：$O(n * m)$

##### KMP 算法
> Knuth Morris Pratt
> 由 D.E.**K**nuth, J.H.**M**orris 和 V.R.**P**ratt 共同提出

**设计思想：**
> 利用已经**部分匹配**的结果而加快模式串的滑动速度？
> 且主串 S 的指针 i **不必回溯**，可提速到 **$O(n+m)$**

**next[j] 函数**
> 表明当模式第 j 个字符与主串中相应字符“失配”时，
> 在模式中需重新和主串中该字符进行比较的字符的位置

- next[j] = 
    - $max\{k | 1<k<j, 且 "P_1 ... P_{k-1}" = "P_{i-k+1} ... P_{j-1}"\}  $
      - $"P_1 ... P_{k-1}"$ 从头开始的 k - 1 个元素
      - $"P_{i-k+1} ... P_{j-1}"$ j 前面 的 k - 1 个元素
      - 集合非空
    - 0 当 j = 1 时
    - 1 其他情况

**算法实现：**
```c
int Index_KMP(SString S, SString T, int pos) {
    i = pos,j = 1;
    while(i < S.length && j < T.length) {
        if(j == 0 || S.ch[i] == T.ch[j]) {
            i++;
            j++;
        } else {
            j = next[j]; // i 不变，j 后退
        }
    }
    if(j > T.length) {
        return i - T.length; // 匹配成功
    } else {
        return 0; // 返回不匹配标志
    }
}

// 获取 next[j]
void get_next(SString T, int &next[]) {
    i = 1;
    next[1] = 0;
    j = 0;
    while(i < T.length) {
        if(j == 0 || T.ch[i] == T.ch[j]) {
            ++i;
            ++j;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
}
```

**next[j] 的改进：**
> 添加了 nextval[]

```c
void get_nextval(SString T, int &nextval[]) {
    i = 1;
    nextval[1] = 0;
    j = 0;
    while(i < T.length) {
        if(j == 0 || T.ch[i] == T.ch[j]) {
            ++i;
            ++j;
            if(T.ch[i] != T.ch[j]) {
                nextval[i] = j;
            } else {
                nextval[i] = nextval[j];
            }
        } else {
            j = nextval[j];
        }
    }
}
```

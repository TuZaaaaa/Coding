# 串、数组和广义表
> 可以理解为 内容受限的线性表，严格来说，已不属于线性结构
## 串
> 串（String） 零个或多个任意**字符组成的有限序列**

- $S = "a_1, a_2, ..., a_n" n \geq 0$
    - 串名：S
    - 串值：$a_1, a_2, ...$
    - 串长：n
    - 空串：n = 0 用 $\emptyset$ 表示

### 几个术语
#### 子串
> 一个串中任意个连续字符组成的**子序列**（含空串）称为该串的子串
> **真子串**是指不包含自身的所有子串

例："abcde" 子串
    - "", "a", "ab", "abc", "abcd", "abcde" 等

#### 主串
> 包含子串的串相应地称为**主串**

#### 字符位置
> 字符**在序列中的序号**为该字符在串中的位置

#### 子串位置
> **子串第一个字符**在主串中的位置

#### 空格串
> 由一个或多个空格组成的串，**与空串不同**

#### 串相等
> 当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是**相等**的
> **所有空串都是相等的**

### 案例引入
#### 病毒感染检测
> 研究者将人的 DNA 和病毒的 DNA 均表示成由一些字母组成的字符串序列
> 检测某种病毒 DNA 序列是否在患者的 DNA 序列中出现过，如果出现过，则此人感染力该病毒，否则 没有感染

例：假设病毒的 DNA 序列为 baa，患者 1 的 DNA 序列为 aaabbba，则感染，患者 2 的 DNA 序列为 babbba，则未感染

> 注意，人的 DNA 序列时线性的，而病毒的 DNA 序列是环状的

### 类型定义
ADT String {
    数据对象：$D = {a_i | a_i \in CharacterSet, i = 1, 2, ..., n, n \geq 0}$
    数据关系：$R_1 = {< a_{i-1}, a_i> | a_{i-1}, a_i \geq D, i = 1, 2, ..., n}$
    基本操作：
        - Strlength(&T, chars); // 串赋值
        - Strcompare(S, T); // 串比较
        - StrLength(S); // 求串长
        - Concat(&T, S1, S2); // 串连结
        - SubString(&Sub, S, pos, len); // 求子串
        - StrCopy(&T, S); // 串拷贝
        - StrEmpty(S); // 串判空
        - ClearString(&S); // 清空串
        - **Index(S, T, pos);** // 子串的位置
        - Replace(&S, T, V); // 串替换
        - StrInsert(&S, pos, T); // 子串插入
        - StrDelete(&S, pos, len); // 子串删除
        - DestoryString(&S); // 串销毁
} ADT String

### 串的顺序存储结构
```c
#define MAXLEN 255
typedef struct {
    char ch[MAXLEN + 1]; // 存储串的一维数组
    int length; // 串的当前长度
} SString
```

### 串的链式存储结构
- 优点：操作方便
- 缺点：存储密度较低
- 可将多个字符放在一个结点中，以克服其缺点

#### 块链结构
```c
#define CHUNKSIZE 80 // 块的大小可由用户定义
typedef struct Chunk {
    char ch[CHUNKSIZE];
    struct Chunk *next;
} Chunk;

typedef struct {
    Chunk *head, *tail; // 串的头指针和尾指针
    int curlen; // 串的当前长度
} LString;  // 字符串的块链结构
```

### 串的操作
#### 串的模式匹配算法
> 确定**主串**中所含**子串**（模式串）第一次出现的位置（定位）

- 算法应用
    - 搜索引擎
    - 拼写检查
    - 语言翻译
    - 数据压缩

- 算法种类
    - BF 算法（Brute-Force，又称古典的，经典的，朴素的，穷举的）
    - KMP 算法（特点：速度快）

##### BF 算法
> Brute-Force 亦称简单匹配算法，采用穷举法的思路

**设计思想：**

`Index(S, T, pos)`
- 将主串的第 pos 个字符和模式串的第一个字符比较
  - 若相等，继续逐个比较后续字符
  - 若不等，从主串的下一字符起，重新与模式串的第一个字符比较
  - 直到主串的一个**连续子串序列**与模式串相等
    - 返回值为 S 中与 T 匹配的子序列第一个字符的序号，即匹配成功
  - 否则，匹配失败，返回值 0

**算法实现：**
```c
int Index_BF(SString S, SString T, int pos) {
    int i = pos, j = 1;
    while(i <= S.length && j <= T.length) {
        if(s.ch[i] == t.ch[j]) { // 主串和子串依次匹配下一字符
            ++i;
            ++j;
        } else { // 主串、子串指针回溯重新开始下一次匹配
            i = i - j + 2;
            j = 1;
        }
    }
    if(j >= T.length) {
        return i - T.length; // 返回匹配的第一个字符的下标
    } else {
        return 0; // 匹配不成功
    }
}
```

**时间复杂度：**
若 n 为主串长度，m 为子串长度，最坏情况：
- 主串前面 n - m 个位置都部分匹配到子串的最后一位
  - 即这 n - m 各比较了 m 次
- 最后 m 位也各比较了 1 次

> 总次数为：$(n - m) * m + m = (n - m + 1) * m$
> 如果 $m << n$，则算法时间复杂度为：$O(n * m)$

##### KMP 算法
> Knuth Morris Pratt
> 由 D.E.**K**nuth, J.H.**M**orris 和 V.R.**P**ratt 共同提出

**设计思想：**
> 利用已经**部分匹配**的结果而加快模式串的滑动速度？
> 且主串 S 的指针 i **不必回溯**，可提速到 **$O(n+m)$**

**next[j] 函数**
> 表明当模式第 j 个字符与主串中相应字符“失配”时，
> 在模式中需重新和主串中该字符进行比较的字符的位置

- next[j] = 
    - $max\{k | 1<k<j, 且 "P_1 ... P_{k-1}" = "P_{i-k+1} ... P_{j-1}"\}  $
      - $"P_1 ... P_{k-1}"$ 从头开始的 k - 1 个元素
      - $"P_{i-k+1} ... P_{j-1}"$ j 前面 的 k - 1 个元素
      - 集合非空
    - 0 当 j = 1 时
    - 1 其他情况

**算法实现：**
```c
int Index_KMP(SString S, SString T, int pos) {
    i = pos,j = 1;
    while(i < S.length && j < T.length) {
        if(j == 0 || S.ch[i] == T.ch[j]) {
            i++;
            j++;
        } else {
            j = next[j]; // i 不变，j 后退
        }
    }
    if(j > T.length) {
        return i - T.length; // 匹配成功
    } else {
        return 0; // 返回不匹配标志
    }
}

// 获取 next[j]
void get_next(SString T, int &next[]) {
    i = 1;
    next[1] = 0;
    j = 0;
    while(i < T.length) {
        if(j == 0 || T.ch[i] == T.ch[j]) {
            ++i;
            ++j;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
}
```

**next[j] 的改进：**
> 添加了 nextval[]

```c
void get_nextval(SString T, int &nextval[]) {
    i = 1;
    nextval[1] = 0;
    j = 0;
    while(i < T.length) {
        if(j == 0 || T.ch[i] == T.ch[j]) {
            ++i;
            ++j;
            if(T.ch[i] != T.ch[j]) {
                nextval[i] = j;
            } else {
                nextval[i] = nextval[j];
            }
        } else {
            j = nextval[j];
        }
    }
}
```

## 数组
> 按一定格式排列起来的，具有**相同类型**的数据元素的集合

- 特点
    - 结构固定：定义后，维数和维界不再改变
- 基本操作
    - 除了结构的初始化和销毁之外，只有取元素和修改元素值的操作

### 一维数组
> 线性表中的数据元素为非结构的简单元素

- 逻辑结构：**线性结构**，定长的线性表
- 声明格式：数据类型 变量名称[长度];

### 二维数组
> 若一维数组中的数据元素又是一维数组结构，则称为二维数组

- 逻辑结构
    - 非线性结构
        - 每一个数据元素既在一个行表中，又在一个列表中
    - 线性结构
        - 定长的线性表，该线性表的每个数据元素也是一个定长的线性表
- 声明格式
    - 数据类型 变量名称[行数][列数]

### 类型定义
ADT Array {
    数据对象：
    $j_i = 0, ... b_i - 1, i = 1, 2, ..., n$
    $D = {a{j_1j_2...j_n} | a{j_1j_2...j_n} \in ElemSet}$
    数据关系：
    $R_1 = \{<a{j_1...j_i...j_n},a{j_1...j_i...ji_n}> | 0 \leq j_k \leq b_k - 1, 1 \leq k \leq n, 且 k \neq i, 0 \leq j_i \leq b_k \leq b_k - 2, a{j_1...j_i...j_n},a{j_1...j_i...j_n} \in D, i = 2, ..., n\}$
}

- n 数组的维数
- $b_i$ 数组第 i 维的长度
- $j_i$ 数组元素第 i 维的下标

例：二维数组的抽象数据类型的数据对象和数据关系的定义
- n = 2（维数为 2，二维数组）
- $b_1$ 第 1 维长度（行数），$b_2$ 第 2 维长度（列数）
- $a_{j1j2}$ 第 1 维下标为 $j_1$，第 2 维下标为 $j_2$

    
数据对象
    - $D = \{a_{ij} | 0 \leq j_i \leq b_1 - 1, 0 \leq j_2 \leq b_2 -1 \}$
数据关系
    - $ROW = \{<a_{j1,j2},a_{j1+1,j2}> | 0 \leq j_1 \leq b_1 - 2, 0 \leq j_2 \leq b_2 - 1 \}$
    - $COL = \{<aj_{j1,j2},a{j1,j2+1}> | 0 \leq j_1 \leq b_1 - 1, 0 \leq j_2 \leq b_2 - 2 \}$
基本操作
    - InitArray(&A n, bound1, ...boundn) // 构造数组A
    - DestroyArray(&A) // 销毁数组 A
    - Value(A, &e, index1, ..., indexn) // 取数组元素值
    - Assign(A, &e, index1, ..., indexn) // 给数组元素赋值

### 顺序存储
> 因为数组一般不做插入和删除操作，所以一般采用**顺序存储**
> 数组可以是多维的，但存储数据元素的内存单元地址是一维的，
> 因此，在存储数组结构前，需要解决多维关系映射到一维关系

- 存储方式
    - 以行序为主序（低下标优先）BASIC, COBOL, PASCAL
    - 以列序为主序（高下标优先）FORTRAN

#### 行序优先
> 设数组开始存储位置 LOC(0, 0)，存储每个元素需要 L 个存储单元
> 数组元素 a[i][j] 的存储位置是：$LOC(i,j) = LOC(0,0) + (n*i+j)*L$
> 在 a[i][j] 前面所有元素个数

#### n 维数组
- 各维元素个数 $m_1, m_2, m_3, ..., m_n$
- 下标为 $i_1, i_2, i_3, ..., i_n$ 的数组元素的存储位置
$LOC(i_1, i_2, ..., i_n) = a + i_1 * m_2 * m_3 * ... * m_n + i_2 * m_3 * m_4 * ... m_n + ... + i_{n-1} * m_n + i_n a + (\sum_{j=1}^{n-1} * \prod_{k=j+1}^{n}m_k) + i_n $

#### 例
> 设有一个二维数组 $A[m][n]$ **按行优先** 顺序存储，假设 $A[0][0]$ 存放位置在 $644_{(10)}$，$A[2][2]$ 存放位置在 $676_{(10)}$，每个元素占一个空间，问 $A[3][3]_{(10)}$ 存放在什么位置？（脚注$_{10}$ 表示用 10 进制表示）

设数组元素 $A[i][j]$ 存放在起始地址为 $LOC(i,j)$ 的存储单元中
$\because Loc(2,2)=Loc(0,0)+2*n+2=644+2*n+2=676$
$\therefore n=(676-2-644)/2=15$
$\therefore Loc(3,3)=Loc(0,0)+3*15+3=644+45+3=692$

### 矩阵压缩存储
> 矩阵：一个由 $m * n$ 个元素排成的 m 行 n 列的表

- 矩阵的常规存储：
    - 将矩阵描述为一个二维数组
- 存储特点：
    - 可以对元素随机存取
    - 矩阵运算简单
    - 存储密度为 1
- 不适宜常规存储的矩阵
    - 值相同的元素很多且呈某种规律分布，零元素多
- 矩阵的压缩存储
    - 为多个相同的非零元素只分配一个存储空间
    - 对零元素不分配空间
- **压缩存储**
    - > 若多个数据元素的**值都相同**，则只分配一个元素值的存储空间，且零元素不占存储空间
- 什么矩阵能够压缩
    - > 一些特殊矩阵，如：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵
    - > 稀疏矩阵：矩阵中非零元素个数较少（一般小于 $5\%$）

#### 对称矩阵压缩
- 特点
    - 沿主对角线对称
    - 在 n * n 的矩阵 a 中，满足如下性质
        - $a_{ij} = a{ji}(1 \leq i,j \leq n)$
- 存储方法
    - 只存储下（或者上）三角（包括主对角线）的数据元素
    - 共占用 $\frac{n(n+1)}{2}$ 个元素空间

> 等差数列求和公式
> $S_n = \frac{n(a_1+a_n)}{2}$

##### 存储结构
> 对称矩阵上下三角的元素数均为：$n(n+1)/2$
> 可以**以行序为主序**将元素存放在一个一维数组 $sa[n(n+1)/2]$ 中

| | | | |
| --- | --- | --- | --- |
| $a_{11}$ | $a_{12}$ | ... | $a_{1n}$ |
| $a_{21}$ | $a_{22}$ | ... | $a_{2n}$ |
| ... | ... | ... | ... |
| $a_{n1}$ | $a_{n2}$ | ... | $a_{nn}$ |

> $[ij]$ 与一维数组中 $[k]$ 的映射关系
- 通过两部分相加得来
    - $\frac{((1+(i-1))(i-1))}{2}$ 1 - (i - 1) 个元素相加 **其上面所有列的元素相加**
    - j - 1 **当前列当前元素前面的元素**


#### 三角矩阵压缩
- 特点：
    - > 对角线以下（或者以上）的数据元素（不包括对角线）全部为常数 c
- 存储方法：
    - 重复元素 c 共享一个元素存储空间，共占用 n(n+1)/2 + 1 个元素
    - 空间：sa[1 .. n(n+1) / 2 + 1]
- 上三角矩阵
    - k = 
        - $i \leq j$
            - $(i-1)*(2_n-i+2)/2+j-1+1$ 
        - $i > j$
            - $n(n+1)/2+1$ 
- 下三角矩阵
    - k = 
        - $i \geq j$
            - $i*(i-1)/2+j$
        - $i < j$
            - $n(n+1)/2+1$

#### 对角矩阵压缩
> 对角矩阵（带状矩阵）
> 在 n * n 的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中
> 区域外的值全为 0，则称为**对角矩阵**，常见的有三对角矩阵，五对角矩阵，七对角矩阵等


#### 稀疏矩阵压缩
> 设在 m * n 的矩阵中有 t 个非零元素
> 令 $a = t | (m * n)$
> 当 $a \leq 0.05$ 时称为**稀疏矩阵**

矩阵 M 由一些组成
    - 三元组(i, j, $a_{ij}$) 唯一确定矩阵一个非零元素
    - 矩阵维度（i, j）

> 压缩存储原则
> 存储各非零元素的值、行列位置和矩阵的行列数
> 三元组的不同表示方式可决定稀疏矩阵不同的压缩存储方法
> 注意：为更可靠描述，通常再加一个总体信息
> - 总行数
> - 总列数
> - 非零元素总个数

##### 三元组顺序表
> 又称**有序的双下标法**

- 优点
    - 非零元素在表中按行序有序存储
    - **便于进行依次顺序处理的矩阵运算**
- 缺点
    - 不能随机存取
    - 若按行号存取某一行中的非零元素，则需从头开始进行查找

##### 十字链表

- 优点
    - **灵活插入**因运算而产生的非零元素
    - **删除**因运算而产生的新的零元素，实现矩阵的各种运算

> 在十字链表中，矩阵的每一个非零元素用一个结点表示
> 该结点除了（row, col, value）以外，还要有两个域
> - right：用于链接同一行中的下一个非零元素
> - down：用于链接同一列中的下一个非零元素



# 线性表
> 线性表（Linear List）是具有相同特性的数据元素的一个有限序列
> 由 $n(n \geq 0)$ 个数据元素（结点）$a_1, a_2, .. a_n$ 组成的**有限序列**

$(a_1, a_2, ..., a_{i-1}, a_i, a_{i+1}, ..., a_n)$

- $a_1$ 起始结点 线性起点
- $a_n$ 终端结点 线性终点
- $a_{i-1}$ $a_i$ 的直接前趋
- $a_{i+1}$ $a_i$ 的直接后继
- 下标，是元素的序号，表示元素在表中的位置
- n 为元素个数，即表长 n = 0 时，称为空表

**线性表的逻辑特征**
- 在非空的线性表，有且仅有一个开始结点 $a_1$，它没有直接前趋，而仅有一个直接后继 $a_2$
- 有且仅有一个终端结点 $a_n$，它没有直接后继，而仅有一个直接前趋 $a_{n-1}$
- 其余的内部结点 $a_i(2 \leqslant i )$ 都由且仅有一个直接前趋 $a_{i-1}$ 和一个直接后继 $a_{i+1}$
- 线性表是一种典型的线性结构

## 线性表类型定义
- 抽象数据类型线性表定义

ADT List {
    数据对象：D = {$a_i | a_i 属于 Element, (i = 1, 2, ..., n, n \geq 0)$}
    数据关系：R = {$<a_{i-1} > | a_{i-1}, a_i 属于 D, (i = 2, 3, ..., n)$}
    基本操作：
    InitList(&L);
    DestoryList(&L);
    ListInsert(&L, i, e);
    ListDelete(&L, i, &e);
} ADT List

- InitList(&L)
    - 操作结果：构造一个空的线性表 L
- DestroyList(&L)
    - 初始条件：线性表 L 已经存在
    - 操作结果：销毁线性表 L
- ClearList(&L)
    - 初始条件：线性表 L 已经存在
    - 操作结果：将线性表 L 重置为空表
- ListEmpty(L)
    - 初始条件：线性表 L 已经存在
    - 操作结果：若线性表 L 为空表，则返回 true，否则返回 false
- ListLength(L)
    - 初始条件：线性表 L 已经存在
    - 操作结果：返回线性表 L 中的数据元素个数
- GetElem(L, i, &e)
    - 初始条件：线性表 L 已经存在，1 <= i <= ListLength(L)
    - 操作结果：用 e 返回线性表 L 中第 i 个数据元素的值
- LocateElem(L, e, compare())
    - 初始条件：线性表 L 已经存在，compare() 是数据元素判定函数
    - 操作结果：返回 L 中第1个与 e 满足 compare() 的数据元素的位序
      - 若这样的数据元素不存在则返回值为 0
- PiorElem(L, cur_e, &pre_e)
    - 初始条件：线性表 L 已经存在
    - 操作结果：若 cur_e 是 L 的数据元素，且不是第一个，则用 pre_e 返回它的前驱
      - 否则操作失败，pre_e 无意义
- NextElem(L, cur_e, &next_e)
    - 初始条件：线性表 L 已经存在
    - 操作结果：若 cur_e 是 L 的数据元素，且不是第一个，则用 next_e 返回它的后继
        - 否则操作失败，next_e 无意义
- ListInsert(&L, i, e)
    - 初始条件：线性表 L 已经存在，1 <= i <= ListLength(L) + 1
    - 操作结果：在 L 的第 i 个位置之前插入新的数据元素 e, L 的长度加一
    - 插入元素 e 之前（长度为 n）：($a_1, a_2, ..., a_{i-1}, a_i, ..., a_n$)
    - 插入元素 e 之前（长度为 n + 1）：($a_1, a_2, ..., a_{i-1}, e, a_i, ..., a_n$)
- ListDelete(&L, i, &e)
    - 初始条件：线性表已经存在，1 <= i <= ListLength(L)
    - 操作结果：删除 L 的第 i 个数据元素，并用 e 返回其值，L 的长度减一
        - 删除前（长度为 n）：
            - ($a_1, a_2, ..., a{i-1}, a_i, a{i+1}, ..., a_n$)
        - 删除后（长度为 n-1）：
            - ($a_1, a_2, ..., a{i-1}, a{i+1}, ..., a_n$)
- ListTraverse(&L, visited())
    - 初始条件：线性表 L 已经存在
    - 操作结果：依次对线性表中每个元素调用 visited()

> 以上所提及的运算时逻辑结构上定义的运算，只要给出这些运算的功能时“做什么”
> 至于“如何做”等实现细节，只有待确定了存储结构之后才考虑

## 线性表的顺序表示和实现
### 表示
> 线性表的顺序表示又称为**顺序存储结构**或**顺序映像**

顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构
- 简言之，逻辑上相邻，物理上也相邻
- 线性表的第一个数据元素 $a_1$ 的存储位置，称为线性表的**起始位置**或**基地址**
- 线性表顺序存储结构**占用一片连续的存储空间**
    - 知道某个元素的存储位置就可以计算其他元素的存储位置

例：如果每个元素占用 8 个存储单元，$a_i$ 存储位置是 2000 单元，则 $a_{i+1}$ 存储位置是？ 2008 单元
假设线性表的每个元素需占 x 个存储单元，则 i + 1 个数据元素的存储位置和第 i 个书元素的存储位置之间满足关系：$LOC(a_{i+1}) = LOC(a_i) + x$
由此，所有数据元素的存储位置均可由第一个数据元素的存储位置得到：$LOC(a_i) = LOC(a_1) + (i - 1) * x$
> 注意：**逻辑位序**和**物理位序**相差1

### 实现
- 顺序表（元素）
    - 地址连续
    - 依次存放
    - 随机存取
    - 类型相同
- 用一维数组表示顺序表
- 线性表长可变（删除）
- 数组长度不可动态定义
    - **用一个变量表示顺序表的长度属性**

```c
    #define LIST_INIT_SIZE 100 // 线性表存储空间的初始分配量
    typedef struct {
        ElemType elem[LIST_INIT_SIZE];
        int length; // 当前长度
    } SqList
```

顺序表示意图：
```c
    #define MAXSIZE 100 // 线性表存储空间的初始分配量
    typedef struct {
        ElemType *elem;
        int length;
    } SqList; // 定义顺序类型
```

就像：
```c
int a; // 定义变量 a，a 是 int 类型
SqList L; // 定义变量 L，L 是 SqList 这种类型的，L 是个顺序表
```

> 补充：操作算法中用到的预定义常量和类型
```c
    // 函数结果状态代码
    #define TRUE 1
    #define FALSE 0
    #define OK 1
    #define ERROR 0
    #define INFERASIBLE -1
    #define OVERFLOW -2 

    // Status 函数的类型，值是函数结构状态代码
    typedef int Status;
    typedef char ElemType;
```
#### 线性表的初始化
```c
    Status InitList_Sq(SqList &L) {         // 构造一个空的顺序表
        L.elem = new ElemType[MAXSIZE];     // 为顺序表分配空间
        if(!L.elem) exit(OVERFLOW);         // 存储分配失败
        L.length = 0;                       // 空表长度为 0
        return OK;
    }
```

#### 销毁线性表 L
```c
    void DestroyList(SqList &L) {
        if(L.elem) delete L.elem; // 释放存储空间
    }
```

#### 清空线性表 L
```c
    void ClearList(SqList &L) {
        L.length = 0; // 将线性表的长度设置为 0
    }
```

#### 求线性表 L 的长度
```c
    int GetLength(SqList L) {
        return (L.length);
    }
```

#### 判断线性表 L 是否为空
```c
    int IsEmpty(SqList L) {
        if(L.length == 0) return 1;
        else return 0;
    }
```

#### 顺序表的取值（根据位置 i 获取相应位置数据元素的内容）
```c
    int GetElem(SqList L, int i, ElemType &e) {
        if(i < 1 || i > L.length) return ERROR; // 判断 i 值是否合理，不合理，返回ERROR
        e = L.elem[i -1];                       // 第 i - 1 的单元存储第 i 个数据
        return OK;
    }
```

#### 查找算法
- 按值查找
- 例如：在图书表中，按照给定书号进行查找，确定是否存在该图书
    - 如果存在：输出是第几个元素
    - 如果不存在：输出 0

- 在线性表 L 中查找与指定值 e 相同的数据元素的位置
- 从表中的一端开始，逐个进行记录的关键字和给定值的比较
    - 找到，返回该元素的位置序号
    - 未找到，返回 0

for 实现
```c
    int LocateELem(SqList L, ElemType e) {
        // 在线性表 L 中查找值为 e 的数据元素，返回其序号（是第几个元素）
        for(i = 0;i < L.length;i++)
            if(L.elem[i] == e) return i + 1;    // 查找成功，返回序号
        return 0;                               // 查找失败，返回 0 
    }
```

while 实现
```c
    int LocateELem(SqList L, ElemType e) {
        // 在线性表 L 中查找值为 e 的数据元素，返回其序号（是第几个元素）
        while(i < L.length && L.elem[i] != e) i++;
        if(i < L.length) return i + 1;    // 查找成功，返回序号
        return 0;                           // 查找失败，返回 0 
    }
```

> 顺序表的查找**算法分析：**
> **平均查找长度** ASL(**A**verage **S**earch **L**ength)
> - 为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值
> 叫做查找算法的**平均查找长度**
> 对含有 n 个记录的表，查找成功时
> $ASL = \sum_{i=1}^n P_iC_i $
> - $P_i$ 第 i 个记录被查找的概率
> - $C_i$ 找到第 i 个记录需比较的次数
> 顺序查找的平均查找长度：$ASL = P_1 + 2P_2 + ... + (n - 1)P_{n-1} + nP_n$
> 假设每个记录的查找概率相等：$P_i = 1/n$
> 则：$ASL = \frac{1}{n}(1 + 2 + 3 + ... + n) = \frac{1}{n} * \frac{n*(n+1)}{2} = \frac{n+1}{2}$
> $ASL_{SS} = \sum_{i=1}^nP_iC_i = \frac{1}{n}\sum_{i=1}^nP_iC_i = \frac{1}{n}\sum_{i=1}^n = \frac{n+1}{2}$

#### 插入算法
> 线性表的插入运算时指在表的 i($1\geq i \geq n+1$) 个位置上，插入一个新结点 e，
> 使长度为 n 的线性表(a1, ..., ai-1, ai, ..., an) 变成长度为 n + 1 的线性表(a1, ..., ai-1, e, ai, ..., an)

算法思想：
1. 判断插入位置 i 是否合法
2. 判断顺序表的存储空间是否已满，若已满返回 ERROR
3. 将第 n 至 i 位的元素依次向后移动一个位置，空出 i 个位置
4. 将要插入的新元素 e 放入第 i 个位置
5. 表长加 1，插入成功返回 OK

算法实现
```c
    Status ListInsert_Sq(SqList &L, int i, ElemType e) {
        if(i < 1 || i > L.length + 1) return ERROR;     // i 值不合法
        if(L.length == MAXSIZE) return ERROR;           // 当前存储空间已满
        for(j = L.length - 1;i >= i - 1;j--)
            L.elem[j + 1] = L.elem[j];                  // 插入位置及之后的元素后移
        L.elem[i - 1] = e;                              // 将新元素 e 放入第 i 个位置
        L.length++;                                     // 表长增 1
        return OK;
    }
```

算法分析
> 算法时间主要耗费在移动元素的操作上
- 若插入在尾结点之后，则根本无需移动（特别快）
- 若插入在首结点之前，则表中元素全部后移（特别慢）
- 若要考虑在各种位置插入（共 n + 1 种可能）的平均移动次数，该如何计算？
$E_{ins} = \frac{1}{n+1}\sum^{n+1}_{i=1}(n-i+1) = \frac{1}{n+1}(n+...+1+0)
= \frac{1}{n+1}\frac{n(n+1)}{2}=\frac{n}{2}$
插入位置 i
平均移动次数 x
$i + x = n + 1$
$x = n + 1 - i$

#### 删除算法
> 线性表的删除运算是指将表的第 i(i <= i <= n) 个结点删除
> 使长度为 n 的线性表 ($a_1, ... a{i-1}, a_i, a{i+1}, ..., a_n$)
> 变成长度为 n-1 的线性表 ($a_1, ... a{i-1}, a{i+1}, ..., a_n$)

算法思想：
1. 判断删除位置 i 是否合法（1 <= i <= n）
2. 将要删除的元素保留在 e 中（可省）
3. 将第 i+1 至第 n 位的元素依次向前移动一个位置
4. 表长减 1，删除成功返回 OK

算法实现：
```c
    Status ListDelete_Sq(SqList &L, int i) {
        if((i < 1) || (i > L.length)) return ERROR;     // i 值不合法
        for(j = i:j <= L.length;j++)
            L.elem[j - 1] = L.elem[j];                  // 被删除元素之后的元素前移
        L.length--;                                     // 表长减 1
        return OK;
    }
```

算法分析
> 算法时间主要耗费在移动元素的操作上
- 若删除尾结点，则根本无需移动（特别快）
- 若删除首结点，则表中 n - 1 个元素全部前移（特别慢）
- 若要考虑在各种位置删除（共 n 种可能）的平均移动次数，该如何计算？
- $E_{del} = \frac{1}{n}\sum^n_{i=1}(n-i) = \frac{(n-1)n}{2} = \frac{n-1}{2}$
- 顺序表删除算法的平均时间复杂度为 $O(n)$

## 顺序表特点小结
- 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致
- 在访问线性表时，可以快速地计算出任何一个数据元素的存储位置
  - 因此可以粗略地认为，访问每个元素所花时间相等
- 这种存取元素的方法被称为**随机存取法**

### 顺序表的操作算法分析
- 时间复杂度
  - 查找、插入、删除算法的平均时间复杂度为 $O(n)$
- 空间复杂度
  - 显然，顺序表操作算法的空间复杂度为 $S(n)=O(1)$
  - 没有占用辅助空间

### 顺序表的优缺点
- 优点
  - 存储密度大（结点本身所占存储量/结点结构所占存储量） = 1
  - 可以随机存取表中任一元素
- 缺点
  - 在插入、删除某一个元素时，需要移动大量元素
  - 浪费存储空间
  - 属于静态存储形式，数据元素的个数不能自由扩充
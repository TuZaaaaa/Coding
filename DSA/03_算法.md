# 算法
> 对特定问题**求解方法和步骤**的一种描述，它是**指令**的有限**序列**
> 其中每个指令表示一个或多个操作

## 算法的特性
- 有穷性
  - 一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成
- 确定性
  - 算法中的每一条指令必须有确切的含义，没有二义性
  - 在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出
- 可行性
  - 算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
- 输入
  - 一个算法有零个或多个输入
- 输出
  - 一个算法有一个或多个输出

## 算法设计的要求
- 正确性（Correctness）
  > 算法满足问题要求，能正确解决问题

  算法转换为程序后要注意：
    - 程序中**不含语法错误**
    - 程序对于**几组输入数据**能够得出满足要求的结果
    - 程序对于**精心选择的、典型、苛刻且带有刁难性**的几组输入数据能够得出满足要求的结果
    - 对于**一切合法的输入数据**都能够得出满足要求的结果
    - 通常以**第三层**意义上的正确性作为衡量一个算法是否合格的标准
- 可读性（Readability）
  - 算法主要是为了人的阅读和交流，其次才是为计算机执行，因此算法应该易于人的理解
  - 另一方面，晦涩难懂的算法易于隐藏较多错误而难以调试
- 健壮性（Robustness）
  - 指当**输入非法数据**时，算法恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果
  - 处理出错的方法，不应是中断程序的执行，而应是返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理
- 高效性（Efficiency）
  - 要求花费尽量少的时间和尽量低的存储需求

### 算法分析
> 一个好的算法首先要具备设计的四大基本要求
> 在基本要求都满足的情况下，主要考虑**算法的效率**
> 通过算法的效率高低来评判不同算法的优劣程度
- 算法效率以下两个方面来考虑
  1. 时间效率：指的是算法所耗费的**时间**
  2. 空间效率：指的是算法执行过程中所耗费的**存储空间**
> 时间效率和空间效率有时候是矛盾的

#### 时间效率的度量
> 算法时间效率可以用依据该算法编制的程序在计算机上执行**所消耗的时间**来度量

- 两种度量方法：
  - 事后统计
    - 将算法实现，测算其时间和空间开销
    - 缺点
        - 编写程序实现算法将花费较多的时间和精力
        - 所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣
  - 事前分析
    - 对算法所消耗资源的一种估算方法

##### 事前分析
> 一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的**时间**与算法中进行的简单操作**次数**乘积
> **算法运行时间 = 一个简单操作所需的时间 x 简单操作次数**
>
> 也即算法中每条语句的执行时间之和
> **算法运行时间 = $\sum_{}^{}$每条语句的执行次数（语句频度） x 该语句执行一次所需的时间**

> 由于每条语句执行一次的时间，一般随机器而异的，与算法无关
> 所以，我们可**假设执行每条语句所需的时间均为单位时间**，此时对算法的运行时间的讨论就可以转化该算法中所有语句的执行次数，即频度之和了
> 这就可以独立于不同机器的软硬件环境来分析算法的时间性能了

##### 算法分析实例
例如：两个 n x n 矩阵相乘的算法可描述为：
```c
    for(i = 1;i <= n;i++) {         // n + 1 次
        for(j = 1;j <= n;j++) {     // n(n + 1) 次 
            c[i][j] = 0;            // n * n 次 
            for(k = 0;k < n;k++) {  // n * n * (n + 1) 次
                c[i][j] = c[i][j] + a[i][k] * b[k][j]; // n * n * n 次
            }
        }
    }
```
> 我们把算法所耗费的时间定义为**该算法中每条语句的频度之和**，
> 则上述算法的时间消耗 T(n) 为：
>   $T(n) = 2n^3 + 3n^2 + 2n + 1$
> n > $\infty$，$T(n)/n^3 > 2$，
> 这表示 n 充分大时，$T(n)$ 与 $n^3$ 时同阶或同数量级，引入大 "O"记号，则$T(n)$可记作：
> $T(n) = O(n^3)$
> 这就是求解矩阵相乘问题的**算法的渐进时间复杂度**
> 一般情况下，不需要计算所有操作的执行次数，只考虑算法中的**基本操作**执行的次数
> 它时问题规模 n 的某个函数，用 $T(n)$ 表示

算法中**基本语句重复执行的次数**时**问题规模 n** 的某个函数 f(n)，
算法的时间量度记作：$T(n) = O(f(n))$

1. 基本语句重复执行的次数
   - 算法中重复执行次数和算法的执行时间成正比的语句
   - 对算法运行时间的贡献最大
   - 执行次数最多
2. 问题规模 n
   - n 越大算法的执行时间越长
     - 排序：n 为记录数
     - 矩阵：n 为矩阵的阶数
     - 多项式：n 为多项式的项数
     - 集合：n 为元素个数
     - 树：n 为树的结点个数
     - 图：n 为图的顶点数或边数

#### 分析算法时间复杂度的基本方法
1. 找出**语句频度最大**的那条语句作为**基本语句**
2. 计算**基本语句**的频度得到问题规模 n 的某个函数 $f(n)$
3. 取其数量级用符号 "O" 来表示

> 有的情况下，算法中基本操作重复执行的次数还随问题的**输入数据集**不同而不同

例：顺序查找值等于 e 的元素，返回其所在位置
```c
    for(i = 0;i < n;i++) {
        if(a[i] == e) {
            return i + 1; // 找到，则返回时第几个元素
        }
        return 0;
    }
```
- 最好情况：1 次
- **最坏情况： n**
- 平均时间复杂度为：O(n)

- 时间复杂度
    - 最坏时间复杂度
      - 指在最坏情况下，算法的时间复杂度
    - 平均时间复杂度
      - 指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间
    - 最好时间复杂度
      - 指在最好情况下，算法的时间复杂度
- 一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长

##### 分而治之
> 对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大 O 加法法则和乘法法则，计算算法的时间复杂度
- 加法规则
  - $T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))$
- 乘法规则
  - $T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(max(f(n) * g(n)))$

##### 算法时间效率的比较
> 当 n 取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊

时间复杂度 T(n) 按数量级递增顺序为：
复杂度低 > 复杂度高
| 常数阶 | 对数阶 | 线性阶 | 线性对数阶 | 平方阶 | 立方阶 | ... | K 次方阶 | 指数阶 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| $O(1)$ | $O(log_2n)$ | $O(n)$ | $O(nlog_n)$ | $O(n^2)$ | $O(n^3)$ | $O(n^4)$ | $O(n^k)$ | $O(2^n)$ |


#### 渐进空间复杂度
- 空间复杂度：算法所需存储空间的度量
  - 记作：$S(n) = O(f(n))$
  - 其中 n 为问题的规模（或大小）
- 算法要占据的空间
  - 算法本身要占据的空间，输入/输出，指令，常熟，变量等
  - 算法要使用的**辅助空间**

## 设计好算法的过程
抽象数据类型 = 数据的逻辑结构 + 抽象运算（运算的功能描述）

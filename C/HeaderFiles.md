# HeaderFiles
> 将函数原型放到一个头文件（以 .h 结尾）中，
> 在需要调用这个函数的源代码文件（.c 文件）中 #include 头文件
> 就能让编译器在编译的时候知道函数的原型

- `#include` 是一个编译预处理指令，和宏一样，在编译之前就处理了
- 它将文件的全部内容原封不动地插入到它所在的地方
- 所以不是一定要在 .c 文件的最前面 #include
- `#include` 有两种形式来指出要插入的文件
  - `""` 要求编译器首先在当前目录（.c 文件所在的目录）寻找那个文件，
    - 如果没有，到编译器指定的目录查找
  - `<>` 编译器只在指定的目录查找
- 编译器知道标准库的头文件在哪里
- 环境变量和编译器命令行参数也可以指定寻找头文件的目录
 
## `#include` 的误区
- `#include` 不是用来引入库的
- `stdio.h` 里只有 `printf` 的原型，代码在另外的地方，某个 .lib(win) 或 .a(Unix) 中
- C 语言编译器默认引入所有标准库
- `#include <stdio.h>` 只是为了让编译器知道 `printf` 函数的原型
  - 保证你调用时给出的参数值时正确的类型
-  在使用和定义这个函数的地方都应该 `#include` 这个头文件
-  一般的做法：任何 .c 文件都有对应的同名的 .h
-  将所有对外公开的函数的原型和全局变量的声明都放进去 

## 声明
### 变量的声明
```c
    extern int i;
```
- 只有声明可以放在头文件中
- 否则会造成一个项目中多个编译单元有重名的实体

### 重复声明
- 同一个编译单元里，同名的结构不能被重复声明
- 如果你的头文件里有结构的声明，很难这个头文件不会在一个编译单元被 `#include` 多次
- 所以需要标准头文件结构
```c
    #ifndef _LIST_HEAD_
    #define _LIST_HEAD_

    #include "node.h"

    typedef struct _list {
        Node* head;
        Node* tail;
    } List;

    #endif
```
- 运用条件编译和宏，保证这个头文件在一个编译单元只会被 `#include` 一次